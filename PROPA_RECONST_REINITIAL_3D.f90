MODULE PROPA_RECONST_REINITIAL_3D
    USE SURFACE_MODULE_3D
    USE SURFACES_3D
    USE OPERATORS_3D
    USE EXTRAPOLATION_3D
    USE SVD
    IMPLICIT NONE
    
    CONTAINS
    SUBROUTINE INTERPOLATE_FLUID_DISPLACEMENT(TYP1_POINT_NUM, TYP1_POINT, TYP1_POINTLOC, TYP1_FACE_NUM, TYP1_FACE, DATA_DISPLACEMENT)
        
	IMPLICIT NONE
    
        INTEGER :: I
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8) :: TYP1_POINT(:,:)
        INTEGER :: TYP1_POINTLOC(:,:)
        INTEGER :: TYP1_FACE_NUM
        INTEGER :: TYP1_FACE(:,:)
        
        INTEGER :: TYP2_POINT_NUM
        REAL(8), POINTER, DIMENSION(:,:) :: TYP2_POINT
        INTEGER, POINTER, DIMENSION(:,:) :: TYP2_POINTLOC
        INTEGER :: TYP2_FACE_NUM
        INTEGER, POINTER, DIMENSION(:,:) :: TYP2_FACE
        
        REAL(8) :: DATA_DISPLACEMENT(:,:)
        
        REAL(8), ALLOCATABLE :: CR_SOURCE(:,:), CR_TARGET(:,:)
        
        CALL UPDATE_INTERFACE_CLUSTER(0)
        
        TYP2_POINT_NUM = INTERFACE_FLUID_POINTS_NUM
        TYP2_POINT => INTERFACE_FLUID_POINTS
        TYP2_POINTLOC => INTERFACE_FLUID_POINTS_LOC
        TYP2_FACE_NUM = INTERFACE_FLUID_FACES_NUM
        TYP2_FACE => INTERFACE_FLUID_FACES
        
        ALLOCATE(CR_SOURCE(3,TYP1_POINT_NUM))
        
	!$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP1_POINT_NUM
            CR_SOURCE(:,I) = DATA_DISPLACEMENT(:,TYP1_POINTLOC(1,I))
        END DO
        !$OMP END PARALLEL DO
        
        ALLOCATE(CR_TARGET(3,TYP2_POINT_NUM))
        
        CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE(1,:), TYP2_POINT_NUM, TYP2_POINT, TYP2_FACE_NUM, TYP2_FACE, CR_TARGET(1,:))
        CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE(2,:), TYP2_POINT_NUM, TYP2_POINT, TYP2_FACE_NUM, TYP2_FACE, CR_TARGET(2,:))
        CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE(3,:), TYP2_POINT_NUM, TYP2_POINT, TYP2_FACE_NUM, TYP2_FACE, CR_TARGET(3,:))
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP2_POINT_NUM
            SURFACE_FLUID%POINT_DISPLACEMENT(:,TYP2_POINTLOC(1,I)) = CR_TARGET(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        DEALLOCATE(CR_SOURCE)
        DEALLOCATE(CR_TARGET)
        
    END SUBROUTINE INTERPOLATE_FLUID_DISPLACEMENT
    
    SUBROUTINE FLUID_MOVE(TIME_STEP) ! TYP = 0 or 1, TYP2 = 0
	IMPLICIT NONE
        REAL(8) :: TIME_STEP
        INTEGER :: I, IDX, IDX2, L, M 
	INTEGER, ALLOCATABLE :: RIDGE_EDGE(:,:)
        INTEGER :: RIDGE_EDGE_NUM, NUM, FACE_INDEX
	REAL(8) :: DIST, DIST1, DIST2, DIST3, TEMPDIST, POINTDIST
	REAL(8) :: A1(3), A2(3), T(3), INNER, INNER2, R
	LOGICAL :: FLAG
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8), ALLOCATABLE :: TYP1_POINT(:,:)
        INTEGER :: TYP1_FACE_NUM
        INTEGER, ALLOCATABLE :: TYP1_FACE(:,:)
        INTEGER, ALLOCATABLE :: TYP1_POINTLOC(:,:)
        REAL(8), ALLOCATABLE :: DATA_DISPLACEMENT(:,:)
        
        !! 1. FLUID MOVING !!
        
        CALL FACEOFFSETTING_3D(0,TIME_STEP)
        
        ALLOCATE(TYP1_POINT(3,INTERFACE_FLUID_POINTS_NUM))
        ALLOCATE(TYP1_POINTLOC(3,INTERFACE_FLUID_POINTS_NUM))
        ALLOCATE(TYP1_FACE(3,INTERFACE_FLUID_FACES_NUM))
        ALLOCATE(DATA_DISPLACEMENT(3,SURFACE_FLUID%SURFACE_POINTS_NUM))
        
        TYP1_POINT_NUM = INTERFACE_FLUID_POINTS_NUM
        TYP1_POINT = INTERFACE_FLUID_POINTS
        TYP1_POINTLOC = INTERFACE_FLUID_POINTS_LOC
        TYP1_FACE_NUM = INTERFACE_FLUID_FACES_NUM
        TYP1_FACE = INTERFACE_FLUID_FACES
        DATA_DISPLACEMENT = SURFACE_FLUID%POINT_DISPLACEMENT
        
        !CALL MODIFIED_NULLSPACE_SMOOTHING(TYP)
        !DO I=1,100
        !    CALL GEOMETRIC_FLOW_SMOOTHING_TRIANGLE(TYP,TIMESTEP)
        !END DO
	CALL NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(0)
        
        CALL INTERPOLATE_FLUID_DISPLACEMENT(TYP1_POINT_NUM, TYP1_POINT, TYP1_POINTLOC, TYP1_FACE_NUM, TYP1_FACE, DATA_DISPLACEMENT)
 
        DEALLOCATE(TYP1_POINT)
        DEALLOCATE(TYP1_POINTLOC)
        DEALLOCATE(TYP1_FACE)
        DEALLOCATE(DATA_DISPLACEMENT)
        
        CALL UPDATE_RELATEDFACE(0,2,.FALSE.)
        
        !! 2. PROPEL MOVING !!
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
            IF(SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)==0) THEN
                SURFACE_PROPEL%POINT_VELOCITY(:,I) = 0.
            ELSE
		IF(SURFACE_PROPEL%POINT_TYPE(I)==5) THEN
		    IDX2 = SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)
		    IF(SURFACE_FLUID%POINT_TYPE(IDX2) == 5) THEN
		        SURFACE_PROPEL%POINT_VELOCITY(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)) - SURFACE_PROPEL%SURFACE_POINTS(:,I)
		    ELSEIF(SURFACE_FLUID%POINT_TYPE(IDX2) == 4) THEN
		        CALL NEIGHBOR_RIDGE_PROJECTION(1,I,0,4)
		    ELSE
		        WRITE(*,*) 'ERROR : POINT TYPE MISMATCH, FLUID RELATED PT TYPE IS NOT 4 OR 5.'
		    END IF
		ELSEIF(SURFACE_PROPEL%POINT_TYPE(I)==4) THEN
                
		CALL NEIGHBOR_RIDGE_PROJECTION(1,I,0,4)
            
                ELSEIF(SURFACE_PROPEL%POINT_TYPE(I)==3) THEN
                    IDX = SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)
  	            IF(SURFACE_FLUID%POINT_TYPE(IDX) == 3) THEN
	                SURFACE_PROPEL%POINT_VELOCITY(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)) - SURFACE_PROPEL%SURFACE_POINTS(:,I)         
	            ELSE
	                CALL NEIGHBOR_RIDGE_PROJECTION(1,I,0,2)
	            END IF
                END IF
	    END IF
        END DO

        !$OMP END PARALLEL DO
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
            SURFACE_PROPEL%SURFACE_POINTS(:,I) = SURFACE_PROPEL%SURFACE_POINTS(:,I) + SURFACE_PROPEL%POINT_VELOCITY(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        CALL UPDATE_RELATEDFACE(1,0,.TRUE.)
        
	!DO I=1,100
	!    CALL GEOMETRIC_FLOW_SMOOTHING(1,TIME_STEP)
	!END DO 
	
        CALL NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(1)

	!CALL SQUARE_NULLSPACE_SMOOTHING(1)
	!DO I = 1,100
	!    CALL GEOMETRIC_FLOW_SMOOTHING(1,TIME_STEP)
	!END DO
        
        !! 3. CASE MOVING !!
        
        DO I=1,SURFACE_CASE%SURFACE_POINTS_NUM
            IF(SURFACE_CASE%POINT_TYPE(I)>=4) THEN
                SURFACE_CASE%SURFACE_POINTS(:,I) = SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_CASE%POINT_RELATEDPT(1+1,I))
            END IF
        END DO
        
        CALL NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(2)
        
        !FLAG = .TRUE.
        !CALL UPDATE_CASE_INTERFACE(FLAG)
        !IF(FLAG) THEN
	!    !CALL FIND_INTERFACE_CLUSTER(0)
        !    CALL FIND_INTERFACE_CLUSTER(1)
        !END IF
        
	!! NOZZLE ABLATION
        CALL UPDATE_RELATEDFACE(2,0,.FALSE.)
        
        !CALL MAINTAIN_CASE_CORNER()
        CALL UPDATE_RELATEDFACE(1,2,.TRUE.)
        
        CALL UPDATE_IMPACT_ZONE(0,0)
        CALL UPDATE_IMPACT_ZONE(0,2)
        CALL UPDATE_IMPACT_ZONE(1,1)     
        
    END SUBROUTINE FLUID_MOVE
    
    SUBROUTINE STRUCT_MOVE()
        IMPLICIT NONE
        INTEGER :: I
        REAL(8) :: ZEROVEC(0)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
            SURFACE_FLUID%POINT_VELOCITY(:,I) = 0.
        END DO
        !$OMP END PARALLEL DO
        
        CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(1,:),SURFACE_CASE%POINT_VELOCITY(1,:),SURFACE_FLUID%POINT_VELOCITY(1,:),ZEROVEC)
        CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(2,:),SURFACE_CASE%POINT_VELOCITY(2,:),SURFACE_FLUID%POINT_VELOCITY(2,:),ZEROVEC)
        CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(3,:),SURFACE_CASE%POINT_VELOCITY(3,:),SURFACE_FLUID%POINT_VELOCITY(3,:),ZEROVEC)
        
        DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
            SURFACE_FLUID%POINT_DISPLACEMENT(:,I) = SURFACE_FLUID%POINT_DISPLACEMENT(:,I) + SURFACE_FLUID%POINT_VELOCITY(:,I)
        END DO
        
    END SUBROUTINE STRUCT_MOVE
   
    SUBROUTINE PRESSURE_TRANSFER()
	IMPLICIT NONE
        INTEGER :: I,J,K,L,I1,I2,I3,I4
	INTEGER :: FACE_NUM
        
	REAL(8), ALLOCATABLE :: FLUID_POINT_PRESSURE(:), FLUID_FACE_AREA(:), FLUID_NORMAL(:,:), NEIGHBOR_AREA_SUM(:)
        
	REAL(8), ALLOCATABLE :: TYP1_POINT(:,:)
	INTEGER, ALLOCATABLE :: TYP1_FACE(:,:), FACE(:,:)
	!INTEGER, ALLOCATABLE :: TYP1_CONNECTION_NUM(:)
	!INTEGER, ALLOCATABLE :: TYP1_CONNECTION(:,:)
	!REAL(8), ALLOCATABLE :: TYP1_NORMAL(:,:)
	!REAL(8), ALLOCATABLE :: TYP1_FACE_AREA(:)	
	REAL(8), ALLOCATABLE :: TYP2_POINT(:,:)
	INTEGER, ALLOCATABLE :: TYP2_FACE(:,:)
	INTEGER, ALLOCATABLE :: CONNECTION_NUM(:), CONNECTION(:,:)
        
	REAL(8), ALLOCATABLE :: NORMAL(:,:), CENTER(:,:), SQUARE_ELEMENT_PRESSURE(:)
	REAL(8), ALLOCATABLE :: AREA(:)
	REAL(8), ALLOCATABLE :: POINT_FORCE(:,:)
	REAL(8), ALLOCATABLE :: CR_SOURCE(:)
	REAL(8), ALLOCATABLE :: CR_TARGET(:)
	REAL(8) :: FLUID_TOTAL_PRESSURE, STRUCT_TOTAL_PRESSURE
	REAL(8) :: V1(3), V2(3), V3(3), V(3), POINT_I1(3), POINT_I2(3),POINT_I3(3), POINT_I4(3),TEMP_FORCE(3), TEMP_NORMAL1(3), TEMP_NORMAL2(3), TEMPVEC(3)
	INTEGER :: TYP1_POINT_NUM, TYP2_POINT_NUM, TYP1_FACE_NUM, TYP2_FACE_NUM, TEMP_FACE_INDEX, IDX
	CHARACTER(500) :: STR

        SURFACE_FLUID%POINT_FORCE(:,:) = 0.
        SURFACE_PROPEL%POINT_FORCE(:,:) = 0.
        SURFACE_CASE%POINT_FORCE(:,:) = 0.
        
        ALLOCATE(FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_POINTS_NUM))
	ALLOCATE(FLUID_FACE_AREA(SURFACE_FLUID%SURFACE_FACES_NUM))
	ALLOCATE(FLUID_NORMAL(3,SURFACE_FLUID%SURFACE_FACES_NUM))
        FLUID_POINT_PRESSURE(:) = 0.
	FLUID_FACE_AREA(:) = 0.
	FLUID_NORMAL(:,:) = 0.
        
        DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
            V1 = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_FLUID%SURFACE_FACES(1,I))
            V2 = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_FLUID%SURFACE_FACES(2,I))
            V3 = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_FLUID%SURFACE_FACES(3,I))
	    CALL VEC_CURL2(V1,V2,V1,V3,FLUID_NORMAL(:,I))
	    FLUID_FACE_AREA(I) = SQRT(DOT_PRODUCT(FLUID_NORMAL(:,I),FLUID_NORMAL(:,I)))/2.
	    FLUID_NORMAL(:,I) = FLUID_NORMAL(:,I)/SQRT(DOT_PRODUCT(FLUID_NORMAL(:,I),FLUID_NORMAL(:,I)))
        END DO

	ALLOCATE(NEIGHBOR_AREA_SUM(SURFACE_FLUID%SURFACE_POINTS_NUM))
	NEIGHBOR_AREA_SUM(:) = 0.

	DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
	    DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
		K = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
		NEIGHBOR_AREA_SUM(I) = NEIGHBOR_AREA_SUM(I) + FLUID_FACE_AREA(K)
	    END DO
	END DO

        DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
            !SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(1,I)) = SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(1,I)) + SURFACE_FLUID%FACE_PRESSURE(I)*FLUID_FACE_AREA(I)/3.*FLUID_NORMAL(:,I)
            !SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(2,I)) = SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(2,I)) + SURFACE_FLUID%FACE_PRESSURE(I)*FLUID_FACE_AREA(I)/3.*FLUID_NORMAL(:,I)
            !SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(3,I)) = SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(3,I)) + SURFACE_FLUID%FACE_PRESSURE(I)*FLUID_FACE_AREA(I)/3.*FLUID_NORMAL(:,I)
            FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(1,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(1,I)) + SURFACE_FLUID%FACE_PRESSURE(I)/SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(SURFACE_FLUID%SURFACE_FACES(1,I))
            FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(2,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(2,I)) + SURFACE_FLUID%FACE_PRESSURE(I)/SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(SURFACE_FLUID%SURFACE_FACES(2,I))
            FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(3,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(3,I)) + SURFACE_FLUID%FACE_PRESSURE(I)/SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(SURFACE_FLUID%SURFACE_FACES(3,I))
        END DO

	!DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
	!    FLUID_POINT_PRESSURE(I) = SQRT(DOT_PRODUCT(SURFACE_FLUID%POINT_FORCE(:,I)/(1./3.*NEIGHBOR_AREA_SUM(I)),SURFACE_FLUID%POINT_FORCE(:,I)/(1./3.*NEIGHBOR_AREA_SUM(I))))
	!END DO

        CALL UPDATE_INTERFACE_CLUSTER(0)
        CALL UPDATE_INTERFACE_CLUSTER(1)

        TYP1_POINT_NUM = INTERFACE_FLUID_POINTS_NUM + INTERFACE_FLUID_FACES_NUM
        ALLOCATE(TYP1_POINT(3,TYP1_POINT_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_FLUID_POINTS_NUM
                TYP1_POINT(:,I) = INTERFACE_FLUID_POINTS(:,I)
        END DO
        !$OMP END PARALLEL DO

	ALLOCATE(CR_SOURCE(TYP1_POINT_NUM))
        DO I=1,TYP1_POINT_NUM
            IF(I<=INTERFACE_FLUID_POINTS_NUM) THEN
                CR_SOURCE(I) = FLUID_POINT_PRESSURE(INTERFACE_FLUID_POINTS_LOC(1,I))
            ELSE
		TEMP_FACE_INDEX = INTERFACE_FLUID_FACES_LOC(1,I-INTERFACE_FLUID_POINTS_NUM)
                CR_SOURCE(I) = SURFACE_FLUID%FACE_PRESSURE(TEMP_FACE_INDEX)
            END IF
	    
        END DO

	TYP1_FACE_NUM = 3*INTERFACE_FLUID_FACES_NUM
        ALLOCATE(TYP1_FACE(3,TYP1_FACE_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_FLUID_FACES_NUM
		I1 = INTERFACE_FLUID_FACES(1,I)
		I2 = INTERFACE_FLUID_FACES(2,I)
		I3 = INTERFACE_FLUID_FACES(3,I)

		TYP1_POINT(:,I+INTERFACE_FLUID_POINTS_NUM) = (INTERFACE_FLUID_POINTS(:,I1) + INTERFACE_FLUID_POINTS(:,I2) + INTERFACE_FLUID_POINTS(:,I3))/3.0

                TYP1_FACE(1,3*I-2) = I1
                TYP1_FACE(2,3*I-2) = I2
                TYP1_FACE(3,3*I-2) = INTERFACE_FLUID_POINTS_NUM + I

                TYP1_FACE(1,3*I-1) = I2
                TYP1_FACE(2,3*I-1) = I3
                TYP1_FACE(3,3*I-1) = INTERFACE_FLUID_POINTS_NUM + I 

                TYP1_FACE(1,3*I-0) = I3
                TYP1_FACE(2,3*I-0) = I1
                TYP1_FACE(3,3*I-0) = INTERFACE_FLUID_POINTS_NUM + I 
        END DO
        !$OMP END PARALLEL DO

	!ALLOCATE(TYP1_CONNECTION_NUM(TYP1_POINT_NUM))
	!ALLOCATE(TYP1_CONNECTION(30,TYP1_POINT_NUM))

	!TYP1_CONNECTION_NUM = 0
	!TYP1_CONNECTION = 0

        !DO I=1,TYP1_FACE_NUM
        !    DO J=1,3
        !        TYP1_CONNECTION_NUM(TYP1_FACE(J,I)) = TYP1_CONNECTION_NUM(TYP1_FACE(J,I)) + 1
        !        TYP1_CONNECTION(TYP1_CONNECTION_NUM(TYP1_FACE(J,I)),TYP1_FACE(J,I)) = I
        !    END DO
        !END DO

	!ALLOCATE(TYP1_NORMAL(3,TYP1_FACE_NUM))
	!ALLOCATE(TYP1_FACE_AREA(TYP1_FACE_NUM))	

        !DO I=1,TYP1_FACE_NUM
        !    V1 = TYP1_POINT(:,TYP1_FACE(1,I))
        !    V2 = TYP1_POINT(:,TYP1_FACE(2,I))
        !    V3 = TYP1_POINT(:,TYP1_FACE(3,I))
	!    CALL VEC_CURL2(V1,V2,V1,V3,V)
	!    TYP1_NORMAL(:,I) = V
	!    TYP1_FACE_AREA(I) = SQRT(DOT_PRODUCT(V,V))/2.
        !END DO

        TYP2_POINT_NUM = INTERFACE_STRUCT_POINTS_NUM + INTERFACE_STRUCT_FACES_NUM
        ALLOCATE(TYP2_POINT(3,TYP2_POINT_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP2_POINT_NUM
            IF(I<=INTERFACE_STRUCT_POINTS_NUM) THEN
                TYP2_POINT(:,I) = INTERFACE_STRUCT_POINTS(:,I)
            ELSE

            END IF
        END DO
        !$OMP END PARALLEL DO

	TYP2_FACE_NUM = 3*INTERFACE_STRUCT_FACES_NUM
        ALLOCATE(TYP2_FACE(3,TYP2_FACE_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_STRUCT_FACES_NUM
		I1 = INTERFACE_STRUCT_FACES(1,I)
		I2 = INTERFACE_STRUCT_FACES(2,I)
		I3 = INTERFACE_STRUCT_FACES(3,I)

                TYP2_POINT(:,I+INTERFACE_STRUCT_POINTS_NUM) = (INTERFACE_STRUCT_POINTS(:,I1) + INTERFACE_STRUCT_POINTS(:,I2) + INTERFACE_STRUCT_POINTS(:,I3))/3.0

	        TYP2_FACE(1,3*I-2) = I1
	        TYP2_FACE(2,3*I-2) = I2
	        TYP2_FACE(3,3*I-2) = INTERFACE_STRUCT_POINTS_NUM + I

	        TYP2_FACE(1,3*I-1) = I2
	        TYP2_FACE(2,3*I-1) = I3
	        TYP2_FACE(3,3*I-1) = INTERFACE_STRUCT_POINTS_NUM + I 

	        TYP2_FACE(1,3*I-0) = I3
	        TYP2_FACE(2,3*I-0) = I1
	        TYP2_FACE(3,3*I-0) = INTERFACE_STRUCT_POINTS_NUM + I 		
        END DO
        !$OMP END PARALLEL DO

	ALLOCATE(CR_TARGET(TYP2_POINT_NUM))
	CR_TARGET(:) = 0.
        
	CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE, TYP2_POINT_NUM, TYP2_POINT, TYP2_FACE_NUM, TYP2_FACE, CR_TARGET)

	!RECOVER QUAD MESH FROM TRIANGULAR MESH	

	FACE_NUM = INTERFACE_STRUCT_FACES_NUM/2
	ALLOCATE(FACE(4,FACE_NUM))

        DO I=1,FACE_NUM
                FACE(1,I) = INTERFACE_STRUCT_FACES(1,2*I-1)
                FACE(2,I) = INTERFACE_STRUCT_FACES(2,2*I-1)
                FACE(3,I) = INTERFACE_STRUCT_FACES(3,2*I-1)
                FACE(4,I) = INTERFACE_STRUCT_FACES(3,2*I)
        END DO

	ALLOCATE(CONNECTION_NUM(INTERFACE_STRUCT_POINTS_NUM))
	ALLOCATE(CONNECTION(30,INTERFACE_STRUCT_POINTS_NUM))

	CONNECTION = 0
	CONNECTION_NUM = 0

	DO I=1,FACE_NUM
            DO J=1,4
                CONNECTION_NUM(FACE(J,I)) = CONNECTION_NUM(FACE(J,I)) + 1
                CONNECTION(CONNECTION_NUM(FACE(J,I)),FACE(J,I)) = I
            END DO
	END DO
	
	ALLOCATE(CENTER(3,FACE_NUM))
        ALLOCATE(NORMAL(3,FACE_NUM))
        ALLOCATE(AREA(FACE_NUM))

        DO I=1,FACE_NUM
            IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1)==1 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I)==1) THEN
		I1 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(1,I))
		I2 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(2,I))
		I3 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(3,I))
		I4 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(4,I))
                POINT_I1 = INTERFACE_STRUCT_POINTS(:,FACE(1,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I1)
                POINT_I2 = INTERFACE_STRUCT_POINTS(:,FACE(2,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I2)
                POINT_I3 = INTERFACE_STRUCT_POINTS(:,FACE(3,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I3)
                POINT_I4 = INTERFACE_STRUCT_POINTS(:,FACE(4,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I4)

            ELSE IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1)==2 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I)==2) THEN
		I1 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(1,I))
		I2 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(2,I))
		I3 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(3,I))
		I4 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(4,I))
                POINT_I1 = INTERFACE_STRUCT_POINTS(:,FACE(1,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I1)
                POINT_I2 = INTERFACE_STRUCT_POINTS(:,FACE(2,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I2)
                POINT_I3 = INTERFACE_STRUCT_POINTS(:,FACE(3,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I3)
                POINT_I4 = INTERFACE_STRUCT_POINTS(:,FACE(4,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I4)
	    ELSE
		WRITE(*,*) 'PRESSURE_TRANSFER : INTERFACE FACE INDEX IS WRONG' 
	    END IF
           
	    CALL VEC_CURL2(POINT_I1,POINT_I2,POINT_I1,POINT_I3,TEMP_NORMAL1)
	    CALL VEC_CURL2(POINT_I1,POINT_I3,POINT_I1,POINT_I4,TEMP_NORMAL2)
	    CENTER(:,I) = (POINT_I1+POINT_I2+POINT_I3+POINT_I4)/4.

	    AREA(I) = (SQRT(DOT_PRODUCT(TEMP_NORMAL1, TEMP_NORMAL1)) + SQRT(DOT_PRODUCT(TEMP_NORMAL2, TEMP_NORMAL2)))/2.
	    NORMAL(:,I) = TEMP_NORMAL1+TEMP_NORMAL2
            NORMAL(:,I) = NORMAL(:,I)/SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I))) 
        END DO
        
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!CR_TARGET = 1.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        ALLOCATE(POINT_FORCE(3,INTERFACE_STRUCT_POINTS_NUM))
        POINT_FORCE(:,:) = 0.

        DO I=1,FACE_NUM
            TEMP_FORCE = (CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)+CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I))/2. * AREA(I)/4. * NORMAL(:,I)
	    IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1) == 1 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I) == 1) THEN
		SURFACE_PROPEL%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I-1)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)
		SURFACE_PROPEL%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I)
	    ELSE IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1) == 2 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I) == 2) THEN
		SURFACE_CASE%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I-1)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)
		SURFACE_CASE%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I)
	    ELSE
		WRITE(*,*) 'PRESSURE_TRANSFER : INTERFACE FACE INDEX IS WRONG' 
	    END IF

	    DO J = 1, 4
		POINT_FORCE(:,FACE(J,I)) = POINT_FORCE(:,FACE(J,I)) + TEMP_FORCE
	    END DO
        END DO

        DO I=1,INTERFACE_STRUCT_POINTS_NUM
	    POINT_FORCE(:,I) = POINT_FORCE(:,I)/CONNECTION_NUM(I)
        END DO
        ALLOCATE(SQUARE_ELEMENT_PRESSURE(FACE_NUM))

        !DO I=1,FACE_NUM
         !   SQUARE_ELEMENT_PRESSURE(I) = (CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)+CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I))/2.
	 !   IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1) == 1 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I) == 1) THEN
	!	SURFACE_PROPEL%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I-1)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)
	!	SURFACE_PROPEL%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I)
	 !   ELSE IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1) == 2 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I) == 2) THEN
	!	SURFACE_CASE%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I-1)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)
	!	SURFACE_CASE%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I)
	 !   ELSE
	!	WRITE(*,*) 'PRESSURE_TRANSFER : INTERFACE FACE INDEX IS WRONG' 
	 !   END IF
        !END DO

        !DO I=1,INTERFACE_STRUCT_POINTS_NUM
	!    DO J=1,CONNECTION_NUM(I)
	!	AREA = 0.
	!	IDX = 0
	!	K = CONNECTION(J,I)
	!	DO L=1,4
	!	    IF(FACE(L,K) == I) THEN
	!		IDX = L
	!		EXIT
	!	    END IF
	!	END DO
	!	I1 = MOD(IDX,4)+1
	!	I2 = MOD(IDX+2,4)+1
	!	CALL VEC_CURL2(INTERFACE_STRUCT_POINTS(:,I),INTERFACE_STRUCT_POINTS(:,I1),INTERFACE_STRUCT_POINTS(:,I),INTERFACE_STRUCT_POINTS(:,I2),TEMPVEC)
	!	AREA = AREA + SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))/2.
	!	CALL VEC_CURL2(INTERFACE_STRUCT_POINTS(:,I1),CENTER(:,K),INTERFACE_STRUCT_POINTS(:,I2),CENTER(:,K),TEMPVEC)
	!	AREA = AREA + SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))/2.
	!	TEMP_FORCE = AREA*SQUARE_ELEMENT_PRESSURE(K)
	!       POINT_FORCE(:,I) = POINT_FORCE(:,I)+ TEMP_FORCE
	!    END DO
        !END DO
      
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_STRUCT_POINTS_NUM
            IF(INTERFACE_STRUCT_POINTS_LOC(2,I)==1) THEN
                SURFACE_PROPEL%POINT_FORCE(:,INTERFACE_STRUCT_POINTS_LOC(1,I)) = -1.*POINT_FORCE(:,I)
            ELSE
                SURFACE_CASE%POINT_FORCE(:,INTERFACE_STRUCT_POINTS_LOC(1,I)) = -1.*POINT_FORCE(:,I)
            END IF
        END DO
        !$OMP END PARALLEL DO

IF(.FALSE.) THEN

	FLUID_TOTAL_PRESSURE = 1.
	STRUCT_TOTAL_PRESSURE = 0.
        TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,1) = FLUID_TOTAL_PRESSURE
        TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,2) = STRUCT_TOTAL_PRESSURE

	IF(FLUID_TOTAL_PRESSURE .NE. 0) THEN
           TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,3) = (STRUCT_TOTAL_PRESSURE-FLUID_TOTAL_PRESSURE)/(FLUID_TOTAL_PRESSURE) 
	END IF
        STR = './output/surface/totalpressure2d.txt'
        
        OPEN(UNIT=21, FILE = STR, ACTION = "WRITE", STATUS = "REPLACE")
        
        DO I = 1, SURFACE_PRESSURE_ITER
            WRITE(21,'(F,F,F)') TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,1), TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,2), TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,3)
        END DO
    
        CLOSE(21)
END IF
	DEALLOCATE(FLUID_POINT_PRESSURE)
	DEALLOCATE(TYP1_POINT)
	DEALLOCATE(TYP1_FACE)
	!DEALLOCATE(TYP1_CONNECTION_NUM)
	!DEALLOCATE(TYP1_CONNECTION)
	!DEALLOCATE(TYP1_NORMAL)
	!DEALLOCATE(TYP1_FACE_AREA)	
	DEALLOCATE(TYP2_POINT)
	DEALLOCATE(TYP2_FACE)
	DEALLOCATE(NORMAL)
	DEALLOCATE(CENTER)
	DEALLOCATE(POINT_FORCE)
        DEALLOCATE(SQUARE_ELEMENT_PRESSURE)
	DEALLOCATE(CR_SOURCE)
	DEALLOCATE(CR_TARGET)
	DEALLOCATE(FACE)
	DEALLOCATE(CONNECTION_NUM)
	DEALLOCATE(CONNECTION)

    END SUBROUTINE PRESSURE_TRANSFER
    
    SUBROUTINE NEIGHBOR_RIDGE_PROJECTION(TYP1,I,TYP2,PROJ_TYP)
	IMPLICIT NONE
        INTEGER :: TYP1, TYP2, PROJ_TYP
        INTEGER :: I, J, L, M, I0, J1, J2, J3, J4, J5, J6, J7, FACE_INDEX, IDX
        REAL(8) :: DIST, TEMPDIST, DIST1, DIST2
	INTEGER, ALLOCATABLE :: RIDGE_EDGE(:,:)
	INTEGER :: RIDGE_EDGE_NUM, NUM
	REAL(8) :: A1(3), A2(3), T(3), R
	LOGICAL :: FLAG
        REAL(8) :: POINTDIST, INNER, INNER2

        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT1, SURFACE_CURRENT2
        
        IF (TYP1==0) THEN
            SURFACE_CURRENT1 => SURFACE_FLUID
        END IF
        IF (TYP1==1) THEN
            SURFACE_CURRENT1 => SURFACE_PROPEL
        END IF
        IF (TYP1==2) THEN
            SURFACE_CURRENT1 => SURFACE_CASE
        END IF        
        
        IF (TYP2==0) THEN
            SURFACE_CURRENT2 => SURFACE_FLUID
        END IF
        IF (TYP2==1) THEN
            SURFACE_CURRENT2 => SURFACE_PROPEL
        END IF
        IF (TYP2==2) THEN
            SURFACE_CURRENT2 => SURFACE_CASE
        END IF        
        
		DIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		DIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
        
		J = SURFACE_CURRENT1%POINT_RELATEDFACE(TYP2+1,I)       
	    ALLOCATE(RIDGE_EDGE(2,100))        
		RIDGE_EDGE_NUM = 0
		DO L= 1,3
		    I0 = SURFACE_CURRENT2%SURFACE_FACES(L,J)
		    NUM = SURFACE_CURRENT2%POINT_FACE_CONNECTION_NUM(I0)
			    DO M= 1,NUM
			    	FACE_INDEX = SURFACE_CURRENT2%POINT_FACE_CONNECTION(M,I0)
				    J1 = SURFACE_CURRENT2%SURFACE_FACES(1,FACE_INDEX)
				    J2 = SURFACE_CURRENT2%SURFACE_FACES(2,FACE_INDEX)
				    J3 = SURFACE_CURRENT2%SURFACE_FACES(3,FACE_INDEX)
				IF(SURFACE_CURRENT2%POINT_TYPE(J1)==PROJ_TYP .AND. SURFACE_CURRENT2%POINT_TYPE(J2)==PROJ_TYP) THEN
				    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
				    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J1
				    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J2
				END IF
				IF(SURFACE_CURRENT2%POINT_TYPE(J2)==PROJ_TYP .AND. SURFACE_CURRENT2%POINT_TYPE(J3)==PROJ_TYP) THEN
				    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
				    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J2
				    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J3
				END IF
				IF(SURFACE_CURRENT2%POINT_TYPE(J3)==PROJ_TYP .AND. SURFACE_CURRENT2%POINT_TYPE(J1)==PROJ_TYP) THEN
				    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
				    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J3
				    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J1
				END IF
			    END DO
		    END DO

	    IF(RIDGE_EDGE_NUM==0) THEN
		WRITE(*,*) 'ERROR : RIDGE_EDGE_NUM == 0, WHEN ATTEMPT TO PROJECTION ONTO RIDGES'
            ELSE
                
			DIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))            
            		TEMPDIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
            
			DO L=1,RIDGE_EDGE_NUM
			    J4 = RIDGE_EDGE(1,L)
			    J5 = RIDGE_EDGE(2,L)
			    CALL UNSIGNED_DISTANCE_EDGE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,J4),SURFACE_CURRENT2%SURFACE_POINTS(:,J5),TEMPDIST)
			    IF(TEMPDIST<DIST) THEN
				DIST = TEMPDIST
				IDX = L
			    END IF
		        END DO
			J6 = RIDGE_EDGE(1,IDX)
			J7 = RIDGE_EDGE(2,IDX)
        
			DIST1 = SQRT(DOT_PRODUCT(SURFACE_CURRENT1%SURFACE_POINTS(:,I)-SURFACE_CURRENT2%SURFACE_POINTS(:,J6),SURFACE_CURRENT1%SURFACE_POINTS(:,I)-SURFACE_CURRENT2%SURFACE_POINTS(:,J6)))
			DIST2 = SQRT(DOT_PRODUCT(SURFACE_CURRENT1%SURFACE_POINTS(:,I)-SURFACE_CURRENT2%SURFACE_POINTS(:,J7),SURFACE_CURRENT1%SURFACE_POINTS(:,I)-SURFACE_CURRENT2%SURFACE_POINTS(:,J7)))
            
			IF(DIST1 < DIST2) THEN
			    A1 = SURFACE_CURRENT2%SURFACE_POINTS(:,J6)
			    A2 = SURFACE_CURRENT2%SURFACE_POINTS(:,J7)
			    
			    POINTDIST = DIST1
			    FLAG = .FALSE.
			ELSE
			    A1 = SURFACE_CURRENT2%SURFACE_POINTS(:,J7)
			    A2 = SURFACE_CURRENT2%SURFACE_POINTS(:,J6)
			    
			    POINTDIST = DIST2
			    FLAG = .TRUE.
			END IF
        
      			INNER = DOT_PRODUCT(A1-SURFACE_CURRENT1%SURFACE_POINTS(:,I),A2-A1)
			T = A2-A1
			R = SQRT(DOT_PRODUCT(T,T))
			T = T/R
			INNER2 = DOT_PRODUCT(SURFACE_CURRENT1%SURFACE_POINTS(:,I)-A1,T)
        
			SURFACE_CURRENT1%POINT_VELOCITY(:,I) = A1 + INNER2 * T- SURFACE_CURRENT1%SURFACE_POINTS(:,I)		
	    END IF
		    DEALLOCATE(RIDGE_EDGE) 			
        
    END SUBROUTINE NEIGHBOR_RIDGE_PROJECTION
    
    SUBROUTINE WAVEFRONT_DISPLACEMENT(TYP, TIMESTEP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        REAL(8) :: TIMESTEP
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        
        REAL(8), ALLOCATABLE :: FACE_AREA(:)
        REAL(8), ALLOCATABLE :: FACE_CENTER(:,:)
        
        INTEGER :: I,J,K,L,M, IDX, POINT_IDX
        INTEGER :: I0,I1,I2,I3, J1,J2,J3,J4,J5,J6,J7, N1,N2,N3,N4,N5,N6, TEMP_I, TEMP1, TEMP2
        REAL(8) :: V(3), V1(3),V2(3),V3(3),R, TEMPVEC(3), TEMP_NORMAL(3), L1, L2
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        INTEGER :: CON_NUM, RELATED_FACE, NEW_RELATED_FACE
        
        INTEGER :: LOCAL_SHAPE
        
        REAL(8), ALLOCATABLE :: N(:,:), A(:), W(:)
        REAL(8) :: W_SUM
        REAL(8) :: B(3)
        
        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        
        INTEGER :: JMIN, TEMP, TEMP_INDEX
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3), TEST_POINT1(3), TEST_POINT2(3)
        
        REAL(8), ALLOCATABLE :: TEMPPOINT(:,:)
        INTEGER :: TEMPFACE(2,10)
        
        REAL(8), ALLOCATABLE :: LENGTH(:)
        REAL(8), ALLOCATABLE :: MU(:), LL(:), COSTHETA(:)
        REAL(8) :: MU_SUM
        LOGICAL :: EXPANDING, FLAG, FLAG1, FLAG2, FLAG3, B0, B1, B2, B3, B4, B5
        LOGICAL, ALLOCATABLE :: POINT_USED(:)
        REAL(8) :: D(3),DIR(3)
        
        REAL(8) :: THETA_A, PHI_C, PHI_R, CHI_C, CHI_R
	REAL(8) :: POINT_DIST, MINDIST, MINDIST1, MINDIST2, DIST1, DIST2, DIST3, DISTANCE
	REAL(8) :: ORIGINAL_MOVE_POINT(3), COPY_POINT(3), PROJ_POINT(3)
    
       INTEGER :: RIDGE_NUM, FACE_IDX, FACE_INDEX, VERTEX, NUM, NEIGHBOR_INDEX, POINT_IDX1, POINT_IDX2, POINT_IDX3, RIDGE(2)
       REAL(8) :: NEIGHBOR_RIDGE_POINT(3,2), TEMP_POINT(3), INNER, INNER1, INNER2, CRI, TEMPDIST,A1(3), A2(3),T(3), CENTER1(3), CENTER2(3)
	REAL(8) :: TEMP_NORMAL2(3),RELATED_NORMAL(3), TEMP_NEIGHBOR_NORMAL(3), NEIGHBOR_NORMAL(3), DIST, DIR1(3), DIR2(3), W1(3), W2(3), TEMP_DIST, POINTDIST
    INTEGER :: RIDGE_EDGE_NUM, SGN1, SGN2
    INTEGER, ALLOCATABLE :: RIDGE_EDGE(:,:)
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        
        ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))
        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
            
            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            
            ! Should modify for square case
            
            CALL VEC_CURL1(V1,V2, NORMAL(:,I))
            
            R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))

if(R < minerror) then
write(*,*) typ, i1, i2, i3
write(*,*) surface_current%surface_points(:,i1)
write(*,*) surface_current%surface_points(:,i2)
write(*,*) surface_current%surface_points(:,i3)
write(*,*) surface_current%point_type(i1), surface_current%point_type(i2), surface_current%point_type(i3)
write(*,*) surface_current%point_relatedface(3,i2), surface_current%point_relatedface(3,i3) 
end if                      
            FACE_AREA(I) = R/2.
            

            NORMAL(:,I) = NORMAL(:,I) / R
            
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM

            CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(A(CON_NUM))
            ALLOCATE(W(CON_NUM))
            
            W_SUM = 0.
            THETA_A = 0.
            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                I1 = SURFACE_CURRENT%SURFACE_FACES(1,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I2 = SURFACE_CURRENT%SURFACE_FACES(2,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I3 = SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF
                
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) / W_SUM
                A(J) = TIMESTEP * SURFACE_CURRENT%FACE_B_RATE(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
                
                B(K) = 0.
                DO J = 1,CON_NUM
                    B(K) = B(K) + W(J)*N(J,K)*A(J)
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,2
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            
            THETA_A = THETA_A - 2.*PI
        
            PHI_R = 14. * PI/180.
            PHI_C = 45. * PI/180.
            
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/4.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF
            
            DISPLACEMENT(:,I) = 0.

	    DO J = 1,LOCAL_SHAPE
                DISPLACEMENT(:,I) = DISPLACEMENT(:,I) + DOT_PRODUCT(E_VECTOR(:,J),B(:))/E_VALUE(J) * E_VECTOR(:,J)
	    END DO
            
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))==0) THEN
                DEALLOCATE(N)
                DEALLOCATE(A)
                DEALLOCATE(W)
                CYCLE
	    END IF

	    !IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))<1E-5 .AND. E_VALUE(2)/E_VALUE(1) > CHI_R/2. .AND. LOCAL_SHAPE == 1) THEN
	!	DISPLACEMENT(:,I) = DISPLACEMENT(:,I) + DOT_PRODUCT(E_VECTOR(:,2),B(:))/E_VALUE(2) * E_VECTOR(:,2)
	    !END IF



IF(SURFACE_CURRENT%POINT_TYPE(I)==2) THEN
	    
        FLAG1 = .FALSE.
	    FLAG2 = .FALSE.
	    FLAG3 = .FALSE.
	    TEMP = 0
		TEMPFACE = 0
	        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
		    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==-1 .AND. .NOT. FLAG1) THEN
			FLAG1 = .TRUE.
           		TEMPFACE(1,1) = K
            	    END IF
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)== 1) THEN
			FLAG2 = .TRUE.
		    END IF
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)== 2) THEN
			FLAG3 = .TRUE.
            		TEMP = TEMP + 1
			TEMPFACE(2,TEMP) = K
		    END IF		
	        END DO

		IF(FLAG1 .AND. FLAG2) THEN
		    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,TEMPFACE(1,1))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(1,1))) 
		    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,TEMPFACE(1,1))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(1,1)))
		    CALL VEC_CURL1(V1,V2,TEMP_NORMAL)
		    TEMP_NORMAL = TEMP_NORMAL/SQRT(DOT_PRODUCT(TEMP_NORMAL,TEMP_NORMAL))
            	    INNER1 = DOT_PRODUCT(TEMP_NORMAL,MODEL_AXIS_EQN(1:3,1))
            	    INNER2 = DOT_PRODUCT(TEMP_NORMAL,MODEL_AXIS_EQN(1:3,2))
            
		    IF(INNER1>=INNER2) THEN
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,1))*MODEL_AXIS_EQN(1:3,1)
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                
		    ELSE
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,2))*MODEL_AXIS_EQN(1:3,2)
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                  
		    END IF 
		END IF

		IF(FLAG1 .AND. FLAG3) THEN
		    TEMP_NORMAL = 0.
		    DO J = 1, TEMP2
		        V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,TEMPFACE(2,J))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(2,J))) 
		        V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,TEMPFACE(2,J))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(2,J)))
		        CALL VEC_CURL1(V1,V2,TEMPVEC)
			    TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
			    TEMP_NORMAL = TEMP_NORMAL + TEMPVEC/REAL(TEMP2)		
		    END DO
		    TEMP_NORMAL = TEMP_NORMAL/SQRT(DOT_PRODUCT(TEMP_NORMAL,TEMP_NORMAL))

		    IF (DOT_PRODUCT(DISPLACEMENT(:,I),TEMP_NORMAL)>0) THEN
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),TEMP_NORMAL)*TEMP_NORMAL
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))
		    END IF
		END IF


ELSE IF(SURFACE_CURRENT%POINT_TYPE(I)==3) THEN
		FLAG = .FALSE.
	        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
		    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==-1) THEN
			FLAG = .TRUE.
			EXIT
		    END IF
	        END DO

		IF(FLAG) THEN
		    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K)) 
		    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
		    CALL VEC_CURL1(V1,V2,TEMPVEC)
		    TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
            INNER1 = DOT_PRODUCT(TEMPVEC,MODEL_AXIS_EQN(1:3,1))
            INNER2 = DOT_PRODUCT(TEMPVEC,MODEL_AXIS_EQN(1:3,2))
            IF(INNER1>=INNER2) THEN
			    DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,1))*MODEL_AXIS_EQN(1:3,1)
			    DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                
            ELSE
			    DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,2))*MODEL_AXIS_EQN(1:3,2)
			    DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                  
            END IF 
		END IF

ELSE IF(SURFACE_CURRENT%POINT_TYPE(I)==4) THEN 

            RIDGE_NUM = 0
            NEIGHBOR_RIDGE_POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
            NEIGHBOR_RIDGE_POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
        
            DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                IF(SURFACE_CURRENT%FACE_ONINTERFACE(FACE_IDX)==1-TYP) THEN
                    DO K = 1, 3
                        IF( SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,FACE_IDX)>0 .AND. (SURFACE_CURRENT%SURFACE_FACES(K,FACE_IDX) .NE. I .OR. SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,FACE_IDX) .NE. I)) THEN
                            IF(SURFACE_CURRENT%SURFACE_FACES(K,FACE_IDX) .NE. I) THEN
                                TEMP_POINT = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K,FACE_IDX))
                            ELSE
                                TEMP_POINT = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,FACE_IDX))					
                            END IF

                            IF(DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1))>MINERROR .AND. DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2))>MINERROR) THEN
                                RIDGE_NUM = RIDGE_NUM + 1
                                NEIGHBOR_RIDGE_POINT(:,RIDGE_NUM) = TEMP_POINT
                                EXIT
                            END IF
                        END IF
                    END DO
                END IF  
                IF(RIDGE_NUM == 2) THEN
		    EXIT
		END IF
            END DO

            IF(RIDGE_NUM < 2) THEN
                WRITE(*,*) 'END OF THE RIDGE FOUND'
                WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,1)
                WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,2)
                WRITE(*,*) 'INDICES : ', I, J
            END IF

            V1 = NEIGHBOR_RIDGE_POINT(:,1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            L1 = SQRT(DOT_PRODUCT(V1,V1))
            V2 = -(NEIGHBOR_RIDGE_POINT(:,2) - SURFACE_CURRENT%SURFACE_POINTS(:,I))
            L2 = SQRT(DOT_PRODUCT(V2,V2))        

            V = L1*V1 + L2*V2
            V = V/SQRT(DOT_PRODUCT(V,V))

            RELATED_FACE = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)
            CENTER1 = (SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)))/3.
            V1 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE)) 
            V2 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE))
            CALL VEC_CURL1(V1,V2,RELATED_NORMAL)
            RELATED_NORMAL = RELATED_NORMAL/SQRT(DOT_PRODUCT(RELATED_NORMAL,RELATED_NORMAL))


            DIST = 100
            B0 = .FALSE.

            DO J = 1, 3
                VERTEX = SURFACE_CASE%SURFACE_FACES(J,RELATED_FACE)
                NUM = SURFACE_CASE%POINT_FACE_CONNECTION_NUM(VERTEX)
                DO L = 1, NUM
                    K = SURFACE_CASE%POINT_FACE_CONNECTION(L,VERTEX)
                    CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,I), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)), TEMP_DIST)	

                    W1 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K))  
                    W2 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K)) 
                    CALL VEC_CURL1(W1,W2,TEMP_NEIGHBOR_NORMAL)
                    TEMP_NEIGHBOR_NORMAL = TEMP_NEIGHBOR_NORMAL/SQRT(DOT_PRODUCT(TEMP_NEIGHBOR_NORMAL,TEMP_NEIGHBOR_NORMAL))
                    CRI = SQRT(MAX(0.,1.-DOT_PRODUCT(RELATED_NORMAL,TEMP_NEIGHBOR_NORMAL)*DOT_PRODUCT(RELATED_NORMAL,TEMP_NEIGHBOR_NORMAL)))

                    IF(K/=RELATED_FACE .AND. TEMP_DIST<DIST .AND. CRI>0.5 .AND. SURFACE_CASE%FACE_ONINTERFACE(K) .NE. -1 ) THEN
                        B0 = .TRUE.
                        DIST = TEMP_DIST
                        NEIGHBOR_NORMAL = TEMP_NEIGHBOR_NORMAL	
                        NEIGHBOR_INDEX = K

                        CENTER2 = (SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)))/3.
                    END IF 

                END DO
            END DO

            CALL VEC_CURL1(RELATED_NORMAL,V,DIR1)
            DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))

            IF(B0) THEN
                CALL VEC_CURL1(NEIGHBOR_NORMAL,V,DIR2)
                IF(DOT_PRODUCT(DIR2,DIR2)<MINERROR) THEN
                    WRITE(*,*) 'PARALLEL PLANES APPEAR WHEN FLUID PT TYP==4, DIR2'
                    WRITE(*,*) 'INDEX :', I
                    WRITE(*,*) 'NEIGHBOR_INDEX :', NEIGHBOR_INDEX
                END IF
            END IF
            IF(DOT_PRODUCT(DIR1,DIR1)<MINERROR) THEN
                WRITE(*,*) 'PARALLEL PLANES APPEAR WHEN FLUID PT TYP==4, DIR1'
                WRITE(*,*) 'INDEX :', I
                WRITE(*,*) 'NEIGHBOR_INDEX :', NEIGHBOR_INDEX
            ELSE
                IF(B0) THEN
                    IF(DOT_PRODUCT(CENTER1-SURFACE_CURRENT%SURFACE_POINTS(:,I),DIR1)<0) THEN
                        DIR1 = -DIR1
                    END IF
                    DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
                    IF(DOT_PRODUCT(CENTER2-SURFACE_CURRENT%SURFACE_POINTS(:,I),DIR2)<0) THEN
                        DIR2 = -DIR2
                    END IF
                    
                    NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                    DO L = 1, NUM
                        K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
                        IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                            W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                            INNER1 = DOT_PRODUCT(TEMP_NORMAL,DIR1)
                            INNER2 = DOT_PRODUCT(TEMP_NORMAL,DIR2)
                            IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                                DIR = DIR1
                                EXIT
                            ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                                DIR = DIR2
                                EXIT
                            ELSE
                                WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==4,5'
                                WRITE(*,*) DIR1
                                WRITE(*,*) DIR2
                                WRITE(*,*) TEMP_NORMAL
                                WRITE(*,*) I, K
                            END IF
                        END IF
                    END DO
                    DISPLACEMENT(:,I) = DIR
                ELSE
                    DIR2 = -DIR1
                    NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                    DO L = 1, NUM
                        K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
                        IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                            W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                            INNER1 = DOT_PRODUCT(TEMP_NORMAL,DIR1)
                            INNER2 = DOT_PRODUCT(TEMP_NORMAL,DIR2)
                            IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                                DIR = DIR1
                                EXIT
                            ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                                DIR = DIR2
                                EXIT
                            ELSE
                                WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==4,5'
                                WRITE(*,*) DIR1
                                WRITE(*,*) DIR2
                                WRITE(*,*) TEMP_NORMAL
                                WRITE(*,*) I, K
                            END IF
                        END IF
                    END DO
                    DISPLACEMENT(:,I) = DIR
                END IF         

            END IF

ELSE IF(SURFACE_CURRENT%POINT_TYPE(I)==5) THEN

        RELATED_FACE = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)
        B1 = .FALSE.
if(related_face==0) then
write(*,*)
end if        
        DO L = 1, 3
            POINT_IDX = SURFACE_CASE%SURFACE_FACES(L,RELATED_FACE)
            IF(SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX)-SURFACE_CURRENT%SURFACE_POINTS(:,I),SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX)-SURFACE_CURRENT%SURFACE_POINTS(:,I)))<SURFACE_FLUID%MESH_SIZE/5.) THEN
                IDX = L
                B1 = .TRUE.
                EXIT
            END IF
        END DO

		J1 = SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE)
		J2 = SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE)
		J3 = SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)

        RIDGE_NUM = 0
        DO L = 1,3
            IF(SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(L,RELATED_FACE)>0) THEN
                RIDGE_NUM = RIDGE_NUM + 1
            END IF
        END DO
        
		N1 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(1,RELATED_FACE)
		N2 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(2,RELATED_FACE)
		N3 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(3,RELATED_FACE)

	IF(.NOT. B1 .AND. RIDGE_NUM == 1) THEN
            IF(N1 .GE. 1) THEN
                POINT_IDX1 = J1
                POINT_IDX2 = J2
            ELSE IF(N2 .GE. 1) THEN
                POINT_IDX1 = J2
                POINT_IDX2 = J3                
            ELSE
                POINT_IDX1 = J3
                POINT_IDX2 = J1                 
            END IF
            
		        DIR1 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                DIR2 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX2) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                
                DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))
                DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
                
                NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                TEMP_NORMAL2 = 0.
                DO L = 1, NUM
                    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
                    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                        W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                        W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                        CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                        TEMP_NORMAL2 = TEMP_NORMAL2 + TEMP_NORMAL                        
                    END IF
                END DO
                TEMP_NORMAL2 = TEMP_NORMAL2/SQRT(DOT_PRODUCT(TEMP_NORMAL2,TEMP_NORMAL2))
                
                INNER1 = DOT_PRODUCT(TEMP_NORMAL2,DIR1)
                INNER2 = DOT_PRODUCT(TEMP_NORMAL2,DIR2)
                
                IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                    DIR = DIR1
                ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                    DIR = DIR2
                ELSE
                    WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==4,5'
                    WRITE(*,*) DIR1
                    WRITE(*,*) DIR2
                    WRITE(*,*) TEMP_NORMAL2
                    WRITE(*,*) I, K
                END IF
                DISPLACEMENT(:,I) = DIR
                
        ELSEIF(.NOT. B1 .AND. RIDGE_NUM == 2) THEN
            IF(N1 .GE. 1 .AND. N2 .GE. 1) THEN
                POINT_IDX1 = J1
                POINT_IDX2 = J2
                POINT_IDX3 = J3
            ELSE IF(N2 .GE. 1 .AND. N3 .GE. 1) THEN
                POINT_IDX1 = J2
                POINT_IDX2 = J3  
                POINT_IDX3 = J1
            ELSE
                POINT_IDX1 = J3
                POINT_IDX2 = J1  
                POINT_IDX3 = J2 
            END IF
            
		    DIR1 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX1) - SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX2)
            DIR2 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX3) - SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX2)
            
            DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))
            DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
     
            TEMPVEC = SURFACE_CURRENT%SURFACE_POINTS(:,I) - SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX2)
            TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
            
            INNER1 = DOT_PRODUCT(TEMPVEC, DIR1)
            INNER2 = DOT_PRODUCT(TEMPVEC, DIR2)
                
            IF(INNER1>=INNER2) THEN
                DIR2 = -DIR1
            ELSE
                DIR1 = -DIR2
            END IF

            NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            TEMP_NORMAL2 = 0.
            DO L = 1, NUM
                K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
                IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                    W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                    W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                    CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                    TEMP_NORMAL2 = TEMP_NORMAL2 + TEMP_NORMAL                        
                END IF
            END DO
            TEMP_NORMAL2 = TEMP_NORMAL2/SQRT(DOT_PRODUCT(TEMP_NORMAL2,TEMP_NORMAL2))

            INNER1 = DOT_PRODUCT(TEMP_NORMAL2,DIR1)
            INNER2 = DOT_PRODUCT(TEMP_NORMAL2,DIR2)

            IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                DIR = DIR1
            ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                DIR = DIR2
            ELSE
                WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==4,5'
                WRITE(*,*) DIR1
                WRITE(*,*) DIR2
                WRITE(*,*) TEMP_NORMAL2
                WRITE(*,*) I, K
            END IF
            DISPLACEMENT(:,I) = DIR
            
           ! MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
           ! MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
                
           ! DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            !    FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            !    IF(SURFACE_CURRENT%FACE_ONINTERFACE(FACE_IDX)==2) THEN
            !        V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
            !        V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
            !        V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
            !        CALL UNSIGNED_DISTANCE_FACE_POINT(TEST_POINT1,V1,V2,V3,DIST1)
            !        CALL UNSIGNED_DISTANCE_FACE_POINT(TEST_POINT2,V1,V2,V3,DIST2)
            !        IF(DIST1<MINDIST1) THEN
            !        MINDIST1 = DIST1
            !        END IF
            !        IF(DIST2<MINDIST2) THEN
            !        MINDIST2 = DIST2
            !        END IF  
            !    END IF
            !END DO
            
            !IF(MINDIST1<MINDIST2) THEN
            !    DISPLACEMENT(:,I) = DIR2  
            !ELSEIF(MINDIST2<MINDIST1) THEN
            !    DISPLACEMENT(:,I) = DIR1                
            !END IF

        ELSEIF(B1) THEN
            
            POINT_IDX = SURFACE_CASE%SURFACE_FACES(IDX,RELATED_FACE)
            NUM = 0           
            DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(POINT_IDX)     
                K = SURFACE_CASE%POINT_FACE_CONNECTION(J,POINT_IDX)
		IF(SURFACE_CASE%FACE_ONINTERFACE(K) == -1)  THEN
		    B5 = .TRUE.
		    EXIT
		END IF
	    END DO

	    IF(B5) THEN
		DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(POINT_IDX) 
                    K = SURFACE_CASE%POINT_FACE_CONNECTION(J,POINT_IDX)
                    IF(SURFACE_CASE%FACE_ONINTERFACE(K) == -1)  THEN
			DO L = 1,3
			    IF(SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(L,K)>0) THEN
				    NUM = NUM + 1
				    IF(L==1) THEN
					I1 = SURFACE_CASE%SURFACE_FACES(1,K)
					I2 = SURFACE_CASE%SURFACE_FACES(2,K)
				    ELSEIF(L==2)THEN
					I1 = SURFACE_CASE%SURFACE_FACES(2,K)
					I2 = SURFACE_CASE%SURFACE_FACES(3,K)
				    ELSE
					I1 = SURFACE_CASE%SURFACE_FACES(3,K)
					I2 = SURFACE_CASE%SURFACE_FACES(1,K)
				    END IF

				    IF(I1==POINT_IDX)THEN
					RIDGE(NUM) = I2
				    ELSE
					RIDGE(NUM) = I1
				    END IF
			    END IF
			END DO
		    END IF
		END DO
	    ELSE
		WRITE(*,*) 'FLUID TYP==5 HAS NO CASE RELATED FACE ONINTERFACE==-1' 
	    END IF

	    DIR1 = SURFACE_CASE%SURFACE_POINTS(:,RIDGE(1)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            DIR2 = SURFACE_CASE%SURFACE_POINTS(:,RIDGE(2)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            
            DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))
            DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))

            NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            TEMP_NORMAL2 = 0.
            DO L = 1, NUM
                K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
                IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                    W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                    W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                    CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                    TEMP_NORMAL2 = TEMP_NORMAL2 + TEMP_NORMAL                        
                END IF
            END DO
            TEMP_NORMAL2 = TEMP_NORMAL2/SQRT(DOT_PRODUCT(TEMP_NORMAL2,TEMP_NORMAL2))

            INNER1 = DOT_PRODUCT(TEMP_NORMAL2,DIR1)
            INNER2 = DOT_PRODUCT(TEMP_NORMAL2,DIR2)

            IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                DIR = DIR1
            ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                DIR = DIR2
            ELSE
                WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==4,5'
                WRITE(*,*) DIR1
                WRITE(*,*) DIR2
                WRITE(*,*) TEMP_NORMAL2
                WRITE(*,*) I, K
            END IF
            DISPLACEMENT(:,I) = DIR
        ELSE
            IF(RIDGE_NUM ==3) THEN
                WRITE(*,*) 'OOPS, RIDGE_NUM ==3 IN WAVEFRONT TYP==5'
            ELSE IF(RIDGE_NUM==0) THEN
  
		        DIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		        DIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
        
		        J = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)       
	            ALLOCATE(RIDGE_EDGE(2,100))  
                ALLOCATE(POINT_USED(SURFACE_CASE%SURFACE_POINTS_NUM))
                POINT_USED = .FALSE.
		        RIDGE_EDGE_NUM = 0
		        DO L= 1,3
		            I0 = SURFACE_CASE%SURFACE_FACES(L,J)
		            NUM = SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I0)
			            DO M= 1,NUM
			    	        FACE_INDEX = SURFACE_CASE%POINT_FACE_CONNECTION(M,I0)
				            J1 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(1,FACE_INDEX)
				            J2 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(2,FACE_INDEX)
				            J3 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(3,FACE_INDEX)
				        IF(J1>0) THEN
                            IF(POINT_USED(SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX))==.FALSE. .OR.  POINT_USED(SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX))==.FALSE.) THEN
				                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX))=.TRUE.
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX))=.TRUE.
				                RIDGE_EDGE(1,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX)
				                RIDGE_EDGE(2,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX)
                            END IF
				        END IF
				        IF(J2>0) THEN
                            IF(POINT_USED(SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX))==.FALSE. .OR.  POINT_USED(SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX))==.FALSE.) THEN
				                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX))=.TRUE.
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX))=.TRUE.
				                RIDGE_EDGE(1,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX)
				                RIDGE_EDGE(2,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX)
                            END IF
				        END IF
				        IF(J3>0) THEN
                            IF(POINT_USED(SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX))==.FALSE. .OR.  POINT_USED(SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX))==.FALSE.) THEN
				                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX))=.TRUE.
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX))=.TRUE.
				                RIDGE_EDGE(1,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX)
				                RIDGE_EDGE(2,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX)
                            END IF
				        END IF
			            END DO
		            END DO

	                IF(RIDGE_EDGE_NUM==0) THEN
		                WRITE(*,*) 'ERROR : RIDGE_EDGE_NUM == 0, WHEN ATTEMPT TO PROJECTION ONTO RIDGES FOR WAVEFRONT TYP==5'
                    ELSE
                
			        DIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))            
            		TEMPDIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
            
			        DO L=1,RIDGE_EDGE_NUM
			            J4 = RIDGE_EDGE(1,L)
			            J5 = RIDGE_EDGE(2,L)
			            CALL UNSIGNED_DISTANCE_EDGE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,I),SURFACE_CASE%SURFACE_POINTS(:,J4),SURFACE_CASE%SURFACE_POINTS(:,J5),TEMPDIST)
			            IF(TEMPDIST<DIST) THEN
				        DIST = TEMPDIST
				        IDX = L
                        END IF
                        IF(TEMPDIST<MINERROR) THEN
                            RIDGE_EDGE_NUM = 1
                            RIDGE_EDGE = 0
                            RIDGE_EDGE(1,1) = J4
                            RIDGE_EDGE(2,1) = J5
                            EXIT
                        END IF
                    END DO
                    
			        J6 = RIDGE_EDGE(1,IDX)
			        J7 = RIDGE_EDGE(2,IDX)
        
			        DIST1 = SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,J6),SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,J6)))
			        DIST2 = SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,J7),SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,J7)))
            
			        IF(DIST1 < DIST2) THEN
			            A1 = SURFACE_CASE%SURFACE_POINTS(:,J6)
			            A2 = SURFACE_CASE%SURFACE_POINTS(:,J7)
			    
			            POINTDIST = DIST1
			        ELSE
			            A1 = SURFACE_CASE%SURFACE_POINTS(:,J7)
			            A2 = SURFACE_CASE%SURFACE_POINTS(:,J6)
			    
			            POINTDIST = DIST2
			        END IF
        
      			        INNER = DOT_PRODUCT(A1-SURFACE_CURRENT%SURFACE_POINTS(:,I),A2-A1)
			        T = A2-A1
			        R = SQRT(DOT_PRODUCT(T,T))
			        T = T/R
			        INNER2 = DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I)-A1,T)
        
			        DISPLACEMENT(:,I) = A1 + INNER2*T - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                    DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))
                    END IF
                    
		            DEALLOCATE(RIDGE_EDGE) 	
                    DEALLOCATE(POINT_USED)

                ELSE
                    WRITE(*,*) 'UNEXPECTED CASE FOR WAVEFRONT TYP==5'
                END IF
           ! B2 = .FALSE.
           ! IF(B1) THEN
           !     DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(POINT_IDX)
           !         NEW_RELATED_FACE = SURFACE_CASE%POINT_FACE_CONNECTION(J,POINT_IDX)
           !         J4 = SURFACE_CASE%SURFACE_FACES(1,NEW_RELATED_FACE)
           !         J5 = SURFACE_CASE%SURFACE_FACES(2,NEW_RELATED_FACE)
			        !J6 = SURFACE_CASE%SURFACE_FACES(3,NEW_RELATED_FACE)
			        !N4 = SURFACE_CASE%POINT_TYPE(J4)
			        !N5 = SURFACE_CASE%POINT_TYPE(J5)
			        !N6 = SURFACE_CASE%POINT_TYPE(J6)
           !         
		         !   IF(N4 .GE. 2 .AND. N5 .GE. 2) THEN
		         !       DIR1 = SURFACE_CASE%SURFACE_POINTS(:,J4) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           !             DIR2 = SURFACE_CASE%SURFACE_POINTS(:,J5) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           ! 
           !             MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		         !       MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))    
           ! 
           !             DO K = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
           !                 FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(K,I)                            
           !                 V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
           !                 V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
           !                 V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
           !                                     
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J4),V1,V2,V3,DIST1)
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J5),V1,V2,V3,DIST2)                            
           !                 IF(DIST1<MINDIST1) THEN
           !                 MINDIST1 = DIST1
           !                 END IF
           !                 IF(DIST2<MINDIST2) THEN
           !                 MINDIST2 = DIST2
           !                 END IF            
           !             END DO
           ! 
           !             IF(MINDIST1<MINDIST2) THEN
           !                 DISPLACEMENT(:,I) = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))    
           !             ELSEIF(MINDIST2<MINDIST1) THEN
           !                 DISPLACEMENT(:,I) = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))                  
           !             END IF
           ! 
		         !   ELSEIF(N5 .GE. 2 .AND. N6 .GE. 2) THEN
		         !       DIR1 = SURFACE_CASE%SURFACE_POINTS(:,J5) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           !             DIR2 = SURFACE_CASE%SURFACE_POINTS(:,J6) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           ! 
           !             MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		         !       MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))    
           ! 
           !             DO K = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
           !                 FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(K,I)
           !                 V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
           !                 V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
           !                 V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
           !                                     
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J5),V1,V2,V3,DIST1)
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J6),V1,V2,V3,DIST2) 
           !                 IF(DIST1<MINDIST1) THEN
           !                 MINDIST1 = DIST1
           !                 END IF
           !                 IF(DIST2<MINDIST2) THEN
           !                 MINDIST2 = DIST2
           !                 END IF            
           !             END DO
           ! 
           !             IF(MINDIST1<MINDIST2) THEN
           !                 DISPLACEMENT(:,I) = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))    
           !             ELSEIF(MINDIST2<MINDIST1) THEN
           !                 DISPLACEMENT(:,I) = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))                  
           !             END IF
           !
		         !   ELSEIF(N6 .GE. 2 .AND. N4 .GE. 2) THEN
		         !       DIR1 = SURFACE_CASE%SURFACE_POINTS(:,J6) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           !             DIR2 = SURFACE_CASE%SURFACE_POINTS(:,J4) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           ! 
           !             MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		         !       MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))    
           ! 
           !             DO K = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
           !                 FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(K,I)
           !                 V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
           !                 V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
           !                 V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
           !                                     
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J6),V1,V2,V3,DIST1)
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J4),V1,V2,V3,DIST2) 
           !                 IF(DIST1<MINDIST1) THEN
           !                 MINDIST1 = DIST1
           !                 END IF
           !                 IF(DIST2<MINDIST2) THEN
           !                 MINDIST2 = DIST2
           !                 END IF            
           !             END DO
           ! 
           !             IF(MINDIST1<MINDIST2) THEN
           !                 DISPLACEMENT(:,I) = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))    
           !             ELSEIF(MINDIST2<MINDIST1) THEN
           !                 DISPLACEMENT(:,I) = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))                  
           !             END IF
           !
           !         ELSE
           !             B2 = .TRUE.
			        !END IF 
           !         
           !     END DO    
           ! END IF    
           ! 
           ! IF(B2) THEN
           !     WRITE(*,*) 'FAIL TO CHANGE RELATED FACE'
           ! END IF
        END IF
            
		 !   MINDIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		 !   B3 = .FALSE.
		 !   DO L = 1, 3
			!TEMP = SURFACE_CASE%SURFACE_FACES(L,RELATED_FACE)
		 !       POINT_DIST = SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,TEMP),SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,TEMP)))
			!IF(POINT_DIST<MINDIST) THEN
			!   MINDIST = POINT_DIST
			!   IDX = TEMP
			!END IF
   !         END DO
   !
   !         B3 = .TRUE.
		 !   
		 !   IF(B3) THEN
			!ORIGINAL_MOVE_POINT = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I) 
			!MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
			!DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(IDX) 
			!    TEMP_INDEX = SURFACE_CASE%POINT_FACE_CONNECTION(J,IDX)
			!    J1 = SURFACE_CASE%SURFACE_FACES(1,TEMP_INDEX)
			!    J2 = SURFACE_CASE%SURFACE_FACES(2,TEMP_INDEX)
			!    J3 = SURFACE_CASE%SURFACE_FACES(3,TEMP_INDEX)
			!    V1 = SURFACE_CASE%SURFACE_POINTS(:,J2)- SURFACE_CASE%SURFACE_POINTS(:,J1)
			!    V2 = SURFACE_CASE%SURFACE_POINTS(:,J3)- SURFACE_CASE%SURFACE_POINTS(:,J1)
			!    CALL VEC_CURL1(V1,V2,TEMP_NORMAL)
			!    TEMP_NORMAL = TEMP_NORMAL/SQRT(DOT_PRODUCT(TEMP_NORMAL,TEMP_NORMAL))
			!    PROJ_POINT = ORIGINAL_MOVE_POINT - DOT_PRODUCT(ORIGINAL_MOVE_POINT,TEMP_NORMAL)*TEMP_NORMAL
			!    CALL UNSIGNED_DISTANCE_FACE_POINT(PROJ_POINT,SURFACE_CASE%SURFACE_POINTS(:,J1),SURFACE_CASE%SURFACE_POINTS(:,J2),SURFACE_CASE%SURFACE_POINTS(:,J3),DISTANCE)
			!	IF(DISTANCE<MINDIST2) THEN
			!	    MINDIST2 = DISTANCE
			!	    SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I) = TEMP_INDEX
			!	END IF
			!END DO

            !END IF
	ELSE
		DO J = 1,LOCAL_SHAPE
                    DISPLACEMENT(:,I) = DISPLACEMENT(:,I) + DOT_PRODUCT(E_VECTOR(:,J),B(:))/E_VALUE(J) * E_VECTOR(:,J)
		END DO
	END IF

	IF(SURFACE_CURRENT%POINT_TYPE(I) .LE. 4) THEN
		FLAG = .FALSE.
	        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
		    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==-1) THEN
			FLAG = .TRUE.
			EXIT
		    END IF
	        END DO

		IF(FLAG) THEN
		    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K)) 
		    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
		    CALL VEC_CURL1(V1,V2,TEMPVEC)
		    TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
            	    INNER1 = DOT_PRODUCT(TEMPVEC,MODEL_AXIS_EQN(1:3,1))
            	    INNER2 = DOT_PRODUCT(TEMPVEC,MODEL_AXIS_EQN(1:3,2))
		    IF(INNER1>=INNER2) THEN
		        DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,1))*MODEL_AXIS_EQN(1:3,1)
		        DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                
		    ELSE
		        DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,2))*MODEL_AXIS_EQN(1:3,2)
		        DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                  
		    END IF 
		END IF
	END IF

            DEALLOCATE(N)
            DEALLOCATE(A)
            DEALLOCATE(W)
            
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))>0) THEN
                SURFACE_CURRENT%POINT_FORCE(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))
            ELSE
                SURFACE_CURRENT%POINT_FORCE(:,I) = 0.
            END IF
        END DO
        
        !CALL NEAR_CASE_DISPLACEMENT(TYP, DISPLACEMENT)
        
        ALLOCATE(TEMPPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            TEMPPOINT(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        
        ALLOCATE(LENGTH(SURFACE_CURRENT%SURFACE_POINTS_NUM))
        LENGTH(:) = 0.
        
        ALLOCATE(FACE_CENTER(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
            
            ! Should modify for square case
            
            !FACE_CENTER(:,I) = (TEMPPOINT(:,I1) + TEMPPOINT(:,I2) + TEMPPOINT(:,I3))/3.
            FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3))/3.
            
        END DO
        
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))<MINERROR) THEN
                LENGTH(I) = 0.
            ELSE
                CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)

                ALLOCATE(A(CON_NUM))
                ALLOCATE(W(CON_NUM))
                ALLOCATE(MU(CON_NUM))
                ALLOCATE(LL(CON_NUM))
                ALLOCATE(COSTHETA(CON_NUM))
                
                MU_SUM = 0.
                
                DO J = 1,CON_NUM
                    W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                    A(J) = TIMESTEP * SURFACE_CURRENT%FACE_B_RATE(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                    COSTHETA(J) = DOT_PRODUCT(DISPLACEMENT(:,I), NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))) &
                    /SQRT( DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)) * DOT_PRODUCT(NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)),NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))) )
                    
                    
                    ! HOW TO EXPANDING?
                    !D(:) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - TEMPPOINT(:,I)
                    D(:) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                    
                    IF(DOT_PRODUCT(DISPLACEMENT(:,I),D)<0) THEN
                        EXPANDING = .TRUE.
                    ELSE
                        EXPANDING = .FALSE.
                    END IF
                    
                    IF(EXPANDING) THEN
                        MU(J) = W(J)
                        LL(J) = A(J)
                    ELSE
                        MU(J) = W(J) * (COSTHETA(J))**2
                        
                        IF(ABS(MU(J))<MINERROR) THEN
                            LL(J) = 0.
                        ELSE
                            LL(J) = A(J) / ABS(COSTHETA(J))
                        END IF
                    END IF
                    
                    IF(ABS(LL(J))>=MINERROR) THEN
                        MU_SUM = MU_SUM + MU(J)
                        LENGTH(I) = LENGTH(I) + MU(J)*LL(J)
                    END IF
                
                END DO
                
                LENGTH(I) = LENGTH(I) / MU_SUM
                
                DEALLOCATE(A)
                DEALLOCATE(W)
                DEALLOCATE(MU)
                DEALLOCATE(LL)
                DEALLOCATE(COSTHETA)
            END IF
        END DO
       
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM 
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))>=MINERROR) DISPLACEMENT(:,I) = LENGTH(I) * DISPLACEMENT(:,I) / SQRT(DOT_PRODUCT(DISPLACEMENT(:,I), DISPLACEMENT(:,I)))  
        END DO
    
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM      
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)  
        END DO
        
        DEALLOCATE(LENGTH)
        DEALLOCATE(FACE_CENTER)
        
        DEALLOCATE(TEMPPOINT)
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)
        
        DEALLOCATE(DISPLACEMENT)
        
    END SUBROUTINE WAVEFRONT_DISPLACEMENT
    
    SUBROUTINE NEAR_CASE_DISPLACEMENT(TYP, DISPLACEMENT)
	IMPLICIT NONE
        INTEGER :: TYP
        REAL(8) :: DISPLACEMENT(:,:)
        REAL(8) :: R, R1, R2, R3
        INTEGER :: I,J,J0,J1, REL, L, L1, N, N0, I1,I2,I3, K
        REAL(8) :: V1(3), V2(3), V(3), NORMAL(3), DIRECTION(3)
        REAL(8) :: TEMP_PT(3)
        REAL(8) :: RMIN
        INTEGER :: NMIN
        INTEGER :: NUM
        LOGICAL :: B,C,D
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            B = .FALSE.
            C = .FALSE.
            DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                J0 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                IF(SURFACE_CURRENT%FACE_ONINTERFACE(J0)==0 .OR. SURFACE_CURRENT%FACE_ONINTERFACE(J0)==1) THEN
                    B = .TRUE.
                ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J0)==2) THEN
                    C = .TRUE.
                END IF
            END DO
            
            IF(B .AND. C) THEN
                
                NUM = 0
                DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                    J0 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                    J1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(MOD(J,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)) + 1,I)
                    IF((SURFACE_CURRENT%FACE_ONINTERFACE(J0)==0 .OR. SURFACE_CURRENT%FACE_ONINTERFACE(J0)==1) &
                       .AND. SURFACE_CURRENT%FACE_ONINTERFACE(J1)==2) THEN
                        DO K=1,3
                            IF(SURFACE_CURRENT%SURFACE_FACES(K,J1)==I) THEN
                                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,J1)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                                NUM = NUM + 1
                                EXIT
                            END IF
                        END DO
                    ELSE IF((SURFACE_CURRENT%FACE_ONINTERFACE(J1)==0 .OR. SURFACE_CURRENT%FACE_ONINTERFACE(J1)==1) &
                       .AND. SURFACE_CURRENT%FACE_ONINTERFACE(J0)==2) THEN
                        DO K=1,3
                            IF(SURFACE_CURRENT%SURFACE_FACES(K,J1)==I) THEN
                                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,J1))
                                NUM = NUM + 1
                                EXIT
                            END IF
                        END DO
                    END IF
                END DO
                !! TESTTEST
                IF(NUM>2) THEN
                    WRITE(*,*) 'ERROR'
                END IF
                !! TESTTEST
                
                V1 = V1 / SQRT(DOT_PRODUCT(V1,V1))
                V2 = V2 / SQRT(DOT_PRODUCT(V2,V2))
                
                V = (V1 + V2)/2.
                V = V / SQRT(DOT_PRODUCT(V,V))
                
                RMIN = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
                NMIN = 0
                
                REL = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)
                
                D = .FALSE.
                DO L=1,3
                    L1 = SURFACE_CASE%SURFACE_FACES(L,REL)
                    DO N=1,SURFACE_CASE%POINT_FACE_CONNECTION_NUM(L1)
                        N0 = SURFACE_CASE%POINT_FACE_CONNECTION(N,L1)
                        
                        I1 = SURFACE_CASE%SURFACE_FACES(1,N0)
                        I2 = SURFACE_CASE%SURFACE_FACES(2,N0)
                        I3 = SURFACE_CASE%SURFACE_FACES(3,N0)
                        
                        V1 = SURFACE_CASE%SURFACE_POINTS(:,I2) - SURFACE_CASE%SURFACE_POINTS(:,I1)
                        V2 = SURFACE_CASE%SURFACE_POINTS(:,I3) - SURFACE_CASE%SURFACE_POINTS(:,I1)
                        
                        CALL VEC_CURL1(V1,V2, NORMAL)
                        NORMAL = NORMAL/SQRT(DOT_PRODUCT(NORMAL,NORMAL))
                        
                        CALL VEC_CURL1(V, NORMAL, DIRECTION)
                        DIRECTION = DIRECTION/SQRT(DOT_PRODUCT(DIRECTION,DIRECTION)) * SURFACE_FLUID%MESH_SIZE/10.
                        
                        CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,I) - DIRECTION, SURFACE_CASE%SURFACE_POINTS(:,I1), SURFACE_CASE%SURFACE_POINTS(:,I2), SURFACE_CASE%SURFACE_POINTS(:,I3), R1)
                        CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,I) + DIRECTION, SURFACE_CASE%SURFACE_POINTS(:,I1), SURFACE_CASE%SURFACE_POINTS(:,I2), SURFACE_CASE%SURFACE_POINTS(:,I3), R2)
                        IF(R1 < SURFACE_FLUID%MESH_SIZE/100.) THEN
                            TEMP_PT = SURFACE_CURRENT%SURFACE_POINTS(:,I) - DIRECTION
                        ELSE IF(R2 < SURFACE_FLUID%MESH_SIZE/100.) THEN
                            TEMP_PT = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DIRECTION
                        ELSE
                            CYCLE
                        END IF
                        
                        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                            J0 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                            IF(SURFACE_CURRENT%FACE_ONINTERFACE(J0)==2) THEN
                                CALL UNSIGNED_DISTANCE_FACE_POINT(TEMP_PT, SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,J0)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,J0)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,J0)), R3)
                                IF(R3 < SURFACE_FLUID%MESH_SIZE/100.) THEN
                                    D = .TRUE.
                                    EXIT
                                END IF
                            END IF
                        END DO
                        
                        IF(D) THEN
                            EXIT
                        END IF
                    END DO
                    
                    IF(D) THEN
                        EXIT
                    END IF
                END DO
                
                DIRECTION = DIRECTION/SQRT(DOT_PRODUCT(DIRECTION,DIRECTION))
                R = SQRT(DOT_PRODUCT(DISPLACEMENT(:,I), DISPLACEMENT(:,I)))
                DISPLACEMENT(:,I) = DIRECTION * R
            END IF
        END DO
        
    END SUBROUTINE NEAR_CASE_DISPLACEMENT
    
    SUBROUTINE NULLSPACE_SMOOTHING(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        
        REAL(8), ALLOCATABLE :: FACE_AREA(:)
        REAL(8), ALLOCATABLE :: FACE_CENTER(:,:)
        
        INTEGER :: I,J,K,L, TEMP_I
        INTEGER :: I1,I2,I3
        REAL(8) :: V1(3),V2(3),R
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        INTEGER :: CON_NUM
        
        INTEGER :: LOCAL_SHAPE
        
        REAL(8), ALLOCATABLE :: N(:,:), W(:), C(:,:)
        REAL(8) :: W_SUM
        
        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        
        INTEGER :: JMIN
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
        
        REAL(8) :: T(3,3), TT(3,3)
        
        REAL(8) :: THETA_A, PHI_C, PHI_R, CHI_C, CHI_R
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        
        ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))
        ALLOCATE(FACE_CENTER(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
	
!	    IF(TYP==0) THEN           
                I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
                I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
                I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
            
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)    

                FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3))/3.
            
                CALL VEC_CURL1(V1,V2, NORMAL(:,I))
            
                R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
                       
                FACE_AREA(I) = R/2.

!if(R < minerror) then
!write(*,*) typ, i1, i2, i3
!write(*,*) surface_current%surface_points(:,i1)
!write(*,*) surface_current%surface_points(:,i2)
!write(*,*) surface_current%surface_points(:,i3)
!write(*,*) surface_current%point_type(i1), surface_current%point_type(i2), surface_current%point_type(i3)
!write(*,*) surface_current%point_relatedface(3,i2), surface_current%point_relatedface(3,i3) 
!write(*,*) surface_case%surface_points(:,surface_case%surface_faces(1,1363)), surface_case%point_type(surface_case%surface_faces(1,1363))
!write(*,*) surface_case%surface_points(:,surface_case%surface_faces(2,1363)), surface_case%point_type(surface_case%surface_faces(2,1363))
!write(*,*) surface_case%surface_points(:,surface_case%surface_faces(3,1363)), surface_case%point_type(surface_case%surface_faces(3,1363))
!end if     

                NORMAL(:,I) = NORMAL(:,I) / R      
!	    ELSE
!                I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
!                I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
!                I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
!		I4 = SURFACE_CURRENT%SURFACE_FACES(4,I)
            
!                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
!                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)    

!                FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3))/3.
            
!                CALL VEC_CURL1(V1,V2, NORMAL(:,I))
            
!                R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
                       
!                FACE_AREA(I) = R/2.
!                NORMAL(:,I) = NORMAL(:,I) / R 
  
!	    END IF

            ! Should modify for square case       
            
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            
            CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))
            ALLOCATE(C(3,CON_NUM))
            
            W_SUM = 0.
            THETA_A = 0.
            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                I1 = SURFACE_CURRENT%SURFACE_FACES(1,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I2 = SURFACE_CURRENT%SURFACE_FACES(2,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I3 = SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF
                
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) / W_SUM
                C(:,J) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            THETA_A = THETA_A - 2.*PI
        
            PHI_R = 10. * PI/180.
            PHI_C = 45. * PI/180.
            
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF
            
            DO J = LOCAL_SHAPE+1, 3
                T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
            END DO
            
            DO K=1,3
                DO L=1,3
                    TT(K,L) = 0.
                    DO J=1,3-LOCAL_SHAPE
                        TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
                    END DO
                END DO
            END DO
            
            DISPLACEMENT(:,I) = 0.
            DO J = 1,CON_NUM
                DO K = 1,3
                    DO L = 1,3
                        DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + W(J)*TT(K,L)*C(L,J)
                    END DO
                END DO
            END DO
            
            DEALLOCATE(N)
            DEALLOCATE(W)
            DEALLOCATE(C)
            
        END DO
        
     !   CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            !IF(SURFACE_CURRENT%POINT_TYPE(I) == 2 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 3) THEN
            IF(SURFACE_CURRENT%POINT_TYPE(I) == 3 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 4 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 5) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO

        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)
        DEALLOCATE(FACE_CENTER)
        
        DEALLOCATE(DISPLACEMENT)
        
    END SUBROUTINE NULLSPACE_SMOOTHING

    SUBROUTINE MODIFIED_NULLSPACE_SMOOTHING(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        INTEGER :: I,J,K,L
        INTEGER :: I1,I2,I3, CON_NUM
        REAL(8) :: V1(3),V2(3)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        !! MODIFIED
        INTEGER :: LOCAL_SHAPE, TEMP_I, JMIN
	REAL(8) :: THETA_A, PHI_R, PHI_C, CHI_R, CHI_C
        !! END MODIFIED
        REAL(8), ALLOCATABLE :: N(:,:), W(:), ORIGIN_W(:), C(:,:), FACE_CENTER(:,:), FACE_AREA(:), T(:,:)
        REAL(8) :: W_SUM, ORIGIN_W_SUM
	REAL(8) :: R

        
        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
        
        REAL(8) :: TT(3,3)
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))        
        ALLOCATE(FACE_CENTER(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM           
            I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
    
            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)    

            FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3))/3.
    
            CALL VEC_CURL1(V1,V2, NORMAL(:,I))
    
            R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
            FACE_AREA(I) = R/2.  
            NORMAL(:,I) = NORMAL(:,I) / R       
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM

            CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))
            ALLOCATE(ORIGIN_W(CON_NUM))
            ALLOCATE(C(3,CON_NUM))
            
            W_SUM = 0.           
	    ORIGIN_W_SUM = 0.
            THETA_A = 0.

            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                ORIGIN_W_SUM = ORIGIN_W_SUM + 1./SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))                
                I1 = SURFACE_CURRENT%SURFACE_FACES(1,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I2 = SURFACE_CURRENT%SURFACE_FACES(2,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I3 = SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF
                
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) / W_SUM
		ORIGIN_W(J) = (1./SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)))/ORIGIN_W_SUM
                C(:,J) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            THETA_A = THETA_A - 2.*PI
        
            PHI_R = 14. * PI/180.
            PHI_C = 10. * PI/180.
            
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF

	    IF(LOCAL_SHAPE .NE. 3) THEN

		ALLOCATE(T(3,3-LOCAL_SHAPE))

		DO J = LOCAL_SHAPE+1, 3
		T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
		END DO

		DO K=1,3
		    DO L=1,3
			TT(K,L) = 0.
			DO J=1,3-LOCAL_SHAPE
			    TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
			END DO
		    END DO
		END DO

		DISPLACEMENT(:,I) = 0.
		DO J = 1,CON_NUM
		    DO K = 1,3
			DO L = 1,3
			    DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + ORIGIN_W(J)*TT(K,L)*C(L,J) !/CON_NUM
			END DO
		    END DO
		END DO
		DEALLOCATE(T)

	    END IF
            
            DEALLOCATE(N)
            DEALLOCATE(W)
	    DEALLOCATE(ORIGIN_W)
            DEALLOCATE(C)
            
        END DO
        
       ! CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SURFACE_CURRENT%POINT_TYPE(I) == 3) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO

        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)  
        DEALLOCATE(FACE_CENTER)
        
        DEALLOCATE(DISPLACEMENT)
        
    END SUBROUTINE MODIFIED_NULLSPACE_SMOOTHING
    


    SUBROUTINE SQUARE_NULLSPACE_SMOOTHING(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        INTEGER :: I,J,K,L
        INTEGER :: I1,I2,I3,I4, CON_NUM
        REAL(8) :: V1(3),V2(3)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        !! MODIFIED
        INTEGER :: LOCAL_SHAPE, TEMP_I, JMIN
	REAL(8) :: THETA_A, PHI_R, PHI_C, CHI_R, CHI_C
        !! END MODIFIED
        REAL(8), ALLOCATABLE :: N(:,:), W(:), ORIGIN_W(:), C(:,:), FACE_CENTER(:,:), FACE_AREA(:), T(:,:)
        REAL(8) :: W_SUM, ORIGIN_W_SUM
	REAL(8) :: R

        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
        REAL(8) :: TT(3,3), TEMP_VECTOR(3)
	INTEGER, ALLOCATABLE :: FACE(:,:), CONNECTION(:,:), CONNECTION_NUM(:)
	REAL(8), ALLOCATABLE :: INITIAL_AREA(:)
	INTEGER :: FACE_NUM
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
	
	FACE_NUM = SURFACE_CURRENT%SURFACE_FACES_NUM/2

        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        ALLOCATE(FACE_AREA(FACE_NUM))        
        ALLOCATE(FACE_CENTER(3,FACE_NUM))
        ALLOCATE(NORMAL(3,FACE_NUM))
        ALLOCATE(FACE(4,FACE_NUM))
	ALLOCATE(CONNECTION(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(CONNECTION_NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(INITIAL_AREA(FACE_NUM))
	DISPLACEMENT = 0
	FACE_AREA = 0
	FACE_CENTER = 0
	NORMAL = 0
	FACE = 0
        CONNECTION = 0
	CONNECTION_NUM = 0
	INITIAL_AREA = 0

        DO I=1,FACE_NUM
            FACE(1,I) = SURFACE_CURRENT%SURFACE_FACES(1,2*I-1)
            FACE(2,I) = SURFACE_CURRENT%SURFACE_FACES(2,2*I-1)
            FACE(3,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I-1)
            FACE(4,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I)
            INITIAL_AREA(I) = SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I-1) + SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I)
        END DO

        DO I=1,FACE_NUM
            DO J=1,4
		CONNECTION_NUM(FACE(J,I)) = CONNECTION_NUM(FACE(J,I)) + 1
		CONNECTION(CONNECTION_NUM(FACE(J,I)),FACE(J,I)) = I
            END DO
        END DO

        DO I=1,FACE_NUM           
            I1 = FACE(1,I)
            I2 = FACE(2,I)
            I3 = FACE(3,I)
	    I4 = FACE(4,I)

            FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3) + SURFACE_CURRENT%SURFACE_POINTS(:,I4))/4.

            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)    
            CALL VEC_CURL1(V1,V2, TEMP_VECTOR)
            R = SQRT(DOT_PRODUCT(TEMP_VECTOR, TEMP_VECTOR))
            FACE_AREA(I) = R/2.  
            NORMAL(:,I) = TEMP_VECTOR / R

	    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I4) - SURFACE_CURRENT%SURFACE_POINTS(:,I3)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I1) - SURFACE_CURRENT%SURFACE_POINTS(:,I3)    
            CALL VEC_CURL1(V1,V2, TEMP_VECTOR)
            R = SQRT(DOT_PRODUCT(TEMP_VECTOR, TEMP_VECTOR))
            FACE_AREA(I) = FACE_AREA(I) + R/2.  
            NORMAL(:,I) = (TEMP_VECTOR / R + NORMAL(:,I))/2.0
        END DO
        

        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM

            CON_NUM = CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))
            ALLOCATE(ORIGIN_W(CON_NUM))
            ALLOCATE(C(3,CON_NUM))
            
            W_SUM = 0.           
	    ORIGIN_W_SUM = 0.
            THETA_A = 0.

            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(CONNECTION(J,I))
                ORIGIN_W_SUM = ORIGIN_W_SUM + 1./INITIAL_AREA(CONNECTION(J,I))                
                
                IF(I==I1) THEN
		I1 = FACE(1,CONNECTION(J,I))
                I2 = FACE(2,CONNECTION(J,I))
                I3 = FACE(3,CONNECTION(J,I))
                I4 = FACE(4,CONNECTION(J,I))
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = FACE(2,CONNECTION(J,I))
                    I2 = FACE(3,CONNECTION(J,I))
                    I3 = FACE(4,CONNECTION(J,I))
                    I4 = FACE(1,CONNECTION(J,I))
                ELSE IF(I==I3) THEN
                    TEMP_I = I2
                    I1 = FACE(3,CONNECTION(J,I))
                    I2 = FACE(4,CONNECTION(J,I))
                    I3 = FACE(1,CONNECTION(J,I))
                    I4 = FACE(2,CONNECTION(J,I))
                ELSE
                    TEMP_I = I3
                    I1 = FACE(4,CONNECTION(J,I))
                    I2 = FACE(1,CONNECTION(J,I))
                    I3 = FACE(2,CONNECTION(J,I))
                    I4 = FACE(3,CONNECTION(J,I))
                END IF
                
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I4) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,CONNECTION(J,I))
                W(J) = FACE_AREA(CONNECTION(J,I)) / W_SUM
		ORIGIN_W(J) = (1./INITIAL_AREA(CONNECTION(J,I)))/ORIGIN_W_SUM
                C(:,J) = FACE_CENTER(:,CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            THETA_A = THETA_A - 2.*PI
            PHI_R = 10. * PI/180.
            PHI_C = 45. * PI/180.
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF

	    IF(LOCAL_SHAPE .NE. 3) THEN

		ALLOCATE(T(3,3-LOCAL_SHAPE))

		DO J = LOCAL_SHAPE+1, 3
		T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
		END DO

		DO K=1,3
		    DO L=1,3
			TT(K,L) = 0.
			DO J=1,3-LOCAL_SHAPE
			    TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
			END DO
		    END DO
		END DO

		DISPLACEMENT(:,I) = 0.
		DO J = 1,CON_NUM
		    DO K = 1,3
			DO L = 1,3
			    DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + ORIGIN_W(J)*TT(K,L)*C(L,J)!/CON_NUM
			END DO
		    END DO
		END DO
		DEALLOCATE(T)

	    END IF
            
            DEALLOCATE(N)
            DEALLOCATE(W)
	    DEALLOCATE(ORIGIN_W)
            DEALLOCATE(C)
            
        END DO
        
        ! CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            !IF(SURFACE_CURRENT%POINT_TYPE(I) == 2 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 3) THEN
            IF(SURFACE_CURRENT%POINT_TYPE(I) == 3) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO

        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)  
        DEALLOCATE(FACE_CENTER)
        DEALLOCATE(DISPLACEMENT)
        DEALLOCATE(FACE)
	DEALLOCATE(CONNECTION_NUM)
	DEALLOCATE(CONNECTION)
	DEALLOCATE(INITIAL_AREA)
        
    END SUBROUTINE SQUARE_NULLSPACE_SMOOTHING


    SUBROUTINE GEOMETRIC_FLOW_SMOOTHING(TYP,TIME_STEP)
        IMPLICIT NONE
        
	INTEGER :: TYP
	INTEGER :: FACE_NUM, TEMP, POINT_NUM
	INTEGER :: I,J,K,L, I1,I2,I3, J0, J1, FACE_INDEX, IDX
	INTEGER, ALLOCATABLE :: CONNECTION(:,:), CONNECTION_NUM(:), FACE(:,:), POINT_IDX(:,:), FACE_IDX(:), POINT_INDEX(:), NUM(:)
	REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:), FACE_AREA(:), POINT_NORMAL(:,:,:), POINT_NEIGHBOR(:,:)
	REAL(8) :: U, V, Q, TIME_STEP
	REAL(8) :: POINT(3,4), TEMPPOINT(3), TEMP_POINT(3)
        REAL(8) :: W(3), V1(3), V2(3), V3(3), W1(3), W2(3), Q1(4), Q2(4)
	REAL(8) :: F, AREA, L1, L2
	REAL(8) :: SU(3), SV(3), TEMPVEC(3)
	REAL(8), ALLOCATABLE :: NORMAL(:,:), ALPHA(:), BETA(:), DELTA(:), ALPHA_21(:), ALPHA_43(:), ALPHA_31(:), ALPHA_42(:), WEIGHT(:,:), H(:,:), R1(:,:), MASS_CENTER(:,:)
	REAL(8) :: AREA_SUM
	INTEGER :: RIDGE_NUM, FACEIDX
	REAL(8) :: NEIGHBOR_RIDGE_POINT(3,2)
    
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
       
	FACE_NUM = SURFACE_CURRENT%SURFACE_FACES_NUM/2

        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        ALLOCATE(FACE_AREA(FACE_NUM))        
        ALLOCATE(FACE(4,FACE_NUM))

	DISPLACEMENT = 0.
	FACE_AREA = 0.
	FACE = 0
   
	!RECOVER QUAD MESH FROM TRIANGULAR MESH	
        DO I=1,FACE_NUM
            FACE(1,I) = SURFACE_CURRENT%SURFACE_FACES(1,2*I-1)
            FACE(2,I) = SURFACE_CURRENT%SURFACE_FACES(2,2*I-1)
            FACE(3,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I-1)
            FACE(4,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I)
        END DO

	ALLOCATE(CONNECTION(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(CONNECTION_NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    CONNECTION = 0
    CONNECTION_NUM = 0

        DO I=1,FACE_NUM
            DO J=1,4
		CONNECTION_NUM(FACE(J,I)) = CONNECTION_NUM(FACE(J,I)) + 1
		CONNECTION(CONNECTION_NUM(FACE(J,I)),FACE(J,I)) = I
            END DO
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM      
            ALLOCATE(POINT_INDEX(CONNECTION_NUM(I)))
            POINT_INDEX = 0
            DO J=1,CONNECTION_NUM(I)
                J0 = CONNECTION(J,I)
                DO K=1,4
                    IF(FACE(K,J0)==I) THEN
                        POINT_INDEX(J) = K
                        EXIT
                    END IF
                END DO
            END DO
            
            DO J=1,CONNECTION_NUM(I)
                J0 = CONNECTION(J,I)
                I1 = FACE(MOD(POINT_INDEX(J)+2,4)+1, J0)
                DO K=J+1,CONNECTION_NUM(I)
                    J1 = CONNECTION(K,I)
                    I2 = FACE(MOD(POINT_INDEX(K),4)+1, J1)
                    IF(I1==I2) THEN
                       TEMP = CONNECTION(J+1,I)
                       CONNECTION(J+1,I) = CONNECTION(K,I)
                       CONNECTION(K,I) = TEMP
                       
                       TEMP = POINT_INDEX(J+1)
                       POINT_INDEX(J+1) = POINT_INDEX(K)
                       POINT_INDEX(K) = TEMP
                       
                       EXIT
                    END IF
                END DO
            END DO
            DEALLOCATE(POINT_INDEX)
    END DO        
	!DEFINING QUADRATURE POINTS
        
    Q1 = (/-1.0, 1.0, -1.0, 1.0/)
    Q2 = (/-1.0, -1.0, 1.0, 1.0/)
    Q  = SQRT(3.0)/6.0

	POINT = 0.

	!COMPUTING AREA OF QUAD ELEMENT(INCLUDING NON-COPLANAR CASE)
	DO I = 1, FACE_NUM
	    POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(1,I))
	    POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(2,I))
	    POINT(:,4) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(3,I))
	    POINT(:,3) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(4,I))
	    DO K = 1, 4
            U = 0.5 + Q1(K)*Q
            V = 0.5 + Q2(K)*Q
            SU = (1-V)*(POINT(:,2)-POINT(:,1)) + V*(POINT(:,4)-POINT(:,3))
            SV = (1-U)*(POINT(:,3)-POINT(:,1)) + U*(POINT(:,4)-POINT(:,2))
		    CALL VEC_CURL1(SU,SV,TEMPVEC)
		    F = SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
		    FACE_AREA(I) = FACE_AREA(I) + F/4.
	   END DO
	END DO

        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        NORMAL = 0.
        !COMPUTING NORMALS
        DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
            AREA_SUM = 0.
            DO J = 1, CONNECTION_NUM(I)
                IDX = CONNECTION(J,I)
                AREA_SUM = AREA_SUM + FACE_AREA(IDX)
                DO K = 1, 4
                    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(K,IDX))
                    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(MOD(K,4)+1,IDX))
                    V3 = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(MOD(K+1,4)+1,IDX))
                    W1 = V2 - V1
                    W2 = V3 - V1
                    CALL VEC_CURL1(W1,W2,TEMPVEC)
                    NORMAL(:,I) = NORMAL(:,I) + FACE_AREA(IDX)*TEMPVEC
                END DO
            END DO
            NORMAL(:,I) = NORMAL(:,I)/AREA_SUM
            NORMAL(:,I) = NORMAL(:,I)/SQRT(DOT_PRODUCT(NORMAL(:,I),NORMAL(:,I)))
        END DO

	!APPROXIMATING THE MEAN CURVATURE TERM AND THE TANGENT TERM

	ALLOCATE(H(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(R1(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(MASS_CENTER(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(WEIGHT(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        ALLOCATE(NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(POINT_IDX(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(POINT_NORMAL(3,30,SURFACE_CURRENT%SURFACE_POINTS_NUM))	
	H = 0.
	R1 = 0.
	MASS_CENTER = 0.
	WEIGHT = 0.
	NUM = 0
	POINT_IDX = 0
	POINT_NORMAL = 0.    
	
    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        IF(SURFACE_CURRENT%POINT_TYPE(I)==1 .OR. SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==4) THEN
	    NUM(I) = CONNECTION_NUM(I)
        ALLOCATE(POINT_NEIGHBOR(3,2*NUM(I)))
	    ALLOCATE(ALPHA_21(NUM(I)))
	    ALLOCATE(ALPHA_43(NUM(I)))
	    ALLOCATE(ALPHA_31(NUM(I)))
	    ALLOCATE(ALPHA_42(NUM(I)))
	    ALLOCATE(ALPHA(NUM(I)))
	    ALLOCATE(BETA(NUM(I)))
	    ALLOCATE(DELTA(NUM(I)))
	    ALLOCATE(FACE_IDX(2*NUM(I)))
        ALPHA_21 = 0.
	    ALPHA_43 = 0.
	    ALPHA_31 = 0.
	    ALPHA_42 = 0.
	    ALPHA = 0.
	    BETA = 0.
	    DELTA = 0.
	    AREA_SUM = 0.
        POINT_NEIGHBOR = 0.

	    DO J = 1, NUM(I)
            FACE_INDEX = CONNECTION(J,I)
            AREA = FACE_AREA(FACE_INDEX)
		    AREA_SUM = AREA_SUM + FACE_AREA(FACE_INDEX)
		    
            DO K = 1, 4
		        TEMP = FACE(K,FACE_INDEX)
		        IF(TEMP==I) THEN
			        IDX = K
			    EXIT
		        END IF
            END DO
		
            IF(IDX==1) THEN
		        I1 = 2
		        I2 = 3
		        I3 = 4
		    ELSEIF(IDX==2) THEN
		        I1 = 3
		        I2 = 4
		        I3 = 1
		    ELSEIF(IDX==3) THEN
		        I1 = 4
		        I2 = 1
		        I3 = 2
		    ELSE
		        I1 = 1
		        I2 = 2
		        I3 = 3
            END IF
            
            TEMPPOINT = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(IDX,FACE_INDEX))
            IF(I .NE. FACE(IDX,FACE_INDEX)) THEN
                WRITE(*,*) 'ERROR IN GEOMETRIC_SMOOTHING, CHECK INDEXES'
            END IF
                              
            POINT_NEIGHBOR(:,2*J-1) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(I1,FACE_INDEX))
            POINT_NORMAL(:,2*J-1,I) = NORMAL(:,FACE(I1,FACE_INDEX))
            POINT_IDX(2*J-1,I) = FACE(I1,FACE_INDEX)
		   
            POINT_NEIGHBOR(:,2*J) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(I2,FACE_INDEX))
            POINT_NORMAL(:,2*J,I) = NORMAL(:,FACE(I2,FACE_INDEX))
            POINT_IDX(2*J,I) = FACE(I2,FACE_INDEX)

            POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I))) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(I3,FACE_INDEX))
            POINT_NORMAL(:,MOD(2*J+1,2*NUM(I)),I) = NORMAL(:,FACE(I3,FACE_INDEX))
            POINT_IDX(MOD(2*J+1,2*NUM(I)),I) = FACE(I3,FACE_INDEX)  

		    !COMPUTING ALPHA_21, ALPHA_43, ALPHA_31, ALPHA_42 FOR EACH FACE ADJACENT TO ITH POINT.
		    ALPHA_21 = 0.
		    ALPHA_43 = 0.
		    ALPHA_31 = 0.
		    ALPHA_42 = 0.
           
	        DO K = 1, 4
                U = 0.5 + Q1(K)*Q
                V = 0.5 + Q2(K)*Q                
                SU = (1-V)*(POINT_NEIGHBOR(:,2*J-1)-TEMPPOINT) + V*(POINT_NEIGHBOR(:,2*J)-POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I))))
                SV = (1-U)*(POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I)))-TEMPPOINT) + U * (POINT_NEIGHBOR(:,2*J)-POINT_NEIGHBOR(:,2*J-1))
		        CALL VEC_CURL1(SU,SV,TEMPVEC)
		        F = SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
		        ALPHA_21(J) = ALPHA_21(J) + ((1.- V)*DOT_PRODUCT(SV,(V-1.)*SV-(1.-U)*SU))/(4.*F)
		        ALPHA_43(J) = ALPHA_43(J) + (V*DOT_PRODUCT(SV,(V-1.)*SV-(U-1.)*SU))/(4.*F)
		        ALPHA_31(J) = ALPHA_31(J) + ((1.-U)*DOT_PRODUCT(SU,(U-1.)*SU-(V-1.)*SV))/(4.*F)
		        ALPHA_42(J) = ALPHA_42(J) + (U*DOT_PRODUCT(SU,(U-1.)*SU-(V-1.)*SV))/(4.*F)
	        END DO

		    ALPHA(J) = ALPHA_21(J) - ALPHA_42(J)
		    BETA(J) = ALPHA_31(J) - ALPHA_43(J)
		    DELTA(J) = ALPHA_43(J) + ALPHA_42(J)

	        H(:,I) = H(:,I) + ALPHA(J)*(POINT_NEIGHBOR(:,2*J-1)-TEMPPOINT) + BETA(J)*(POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I)))-TEMPPOINT) + DELTA(J)*(POINT_NEIGHBOR(:,2*J)-TEMPPOINT) 
            MASS_CENTER(:,I) = MASS_CENTER(:,I) + (TEMPPOINT+POINT_NEIGHBOR(:,2*J-1)+POINT_NEIGHBOR(:,2*J)+POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I))))*AREA/4.
                
        END DO
        MASS_CENTER(:,I) = MASS_CENTER(:,I)/AREA_SUM
        
        H(:,I) = H(:,I)/AREA_SUM
        R1(:,I) = R1(:,I) + (MASS_CENTER(:,I)-TEMPPOINT)-DOT_PRODUCT(NORMAL(:,I),MASS_CENTER(:,I)-TEMPPOINT)*NORMAL(:,I)
        
        DO L = 1, NUM(I)
		    IF(L==1) THEN
		        WEIGHT(2*L-1,I) = ALPHA(L)
		        WEIGHT(2*L,I) = DELTA(L)
            ELSEIF(L==NUM(I)) THEN
		        WEIGHT(2*L,I) = DELTA(L)            
            ELSE
		        WEIGHT(2*L-1,I) = ALPHA(L) + BETA(L-1)
		        WEIGHT(2*L,I) = DELTA(L)
		        WEIGHT(2*L+1,I) = ALPHA(L+1) + BETA(L)
		    END IF
        END DO

	   WEIGHT(:,I) = WEIGHT(:,I)/AREA_SUM

        DEALLOCATE(POINT_NEIGHBOR)
	DEALLOCATE(ALPHA_21)
	DEALLOCATE(ALPHA_43)
	DEALLOCATE(ALPHA_31)
	DEALLOCATE(ALPHA_42)
	DEALLOCATE(ALPHA)
	DEALLOCATE(BETA)
	DEALLOCATE(DELTA)
        DEALLOCATE(FACE_IDX)
        END IF

	IF(SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==4) THEN        
	    RIDGE_NUM = 0
	    NEIGHBOR_RIDGE_POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
	    NEIGHBOR_RIDGE_POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,I)

	    DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
	    FACEIDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
	        DO K = 1, 3
		    IF( SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,FACEIDX)>0 .AND. ((SURFACE_CURRENT%SURFACE_FACES(K,FACEIDX).EQ.I) .OR. (SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,FACEIDX).EQ. I))) THEN
			IF(SURFACE_CURRENT%SURFACE_FACES(K,FACEIDX) .EQ. I) THEN
			    TEMP_POINT = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,FACEIDX))
			ELSE
			    TEMP_POINT = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K,FACEIDX))					
			END IF

		        IF(DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1))>MINERROR .AND. DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2))>MINERROR) THEN
		            RIDGE_NUM = RIDGE_NUM + 1
		            NEIGHBOR_RIDGE_POINT(:,RIDGE_NUM) = TEMP_POINT
		            EXIT
		        END IF
		    END IF
	        END DO
	        IF(RIDGE_NUM == 2) EXIT
	    END DO

	    IF(RIDGE_NUM < 2) THEN
	        WRITE(*,*) 'END OF THE RIDGE FOUND IN GEOMETRIC SMOOTHING'
	        WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,1)
	        WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,2)
	        WRITE(*,*) 'INDICES : ', I, J
	    END IF

	    V1 = NEIGHBOR_RIDGE_POINT(:,1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
	    L1 = SQRT(DOT_PRODUCT(V1,V1))
	    V2 = -(NEIGHBOR_RIDGE_POINT(:,2) - SURFACE_CURRENT%SURFACE_POINTS(:,I))
	    L2 = SQRT(DOT_PRODUCT(V2,V2))        

	    W = L1*V1 + L2*V2
	    W = W/SQRT(DOT_PRODUCT(W,W))
		
	    IF(DOT_PRODUCT(R1(:,I),W)<0) THEN
		W = -1.*W
	    END IF
	    R1(:,I) = DOT_PRODUCT(R1(:,I),W)*W
	END IF
    END DO
   
 !   DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
 !       DO L = 1, 2*NUM(I)
 !           TEMP = DOT_PRODUCT(POINT_NORMAL(:,L,I),H(:,POINT_IDX(L,I)))
 !	        R1(:,I) = R1(:,I) + 2*WEIGHT(L,I)*(TEMP*NORMAL(:,I)-H(:,I))
 !       END DO
 !   END DO

        !TIME-INTEGRATION
    
    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
       SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + 1./10.*R1(:,I)
    END DO
    
    DEALLOCATE(DISPLACEMENT)
    DEALLOCATE(FACE_AREA)        
    DEALLOCATE(FACE)
    DEALLOCATE(CONNECTION)
    DEALLOCATE(CONNECTION_NUM)
    DEALLOCATE(H)
    DEALLOCATE(R1)
    DEALLOCATE(MASS_CENTER)
    DEALLOCATE(NORMAL)
    DEALLOCATE(NUM)
    DEALLOCATE(POINT_IDX)
    DEALLOCATE(POINT_NORMAL)
    DEALLOCATE(WEIGHT)

    END SUBROUTINE GEOMETRIC_FLOW_SMOOTHING
    
    SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TRIANGLE(TYP,TIME_STEP)
        IMPLICIT NONE
        
	INTEGER :: TYP
	INTEGER :: FACE_NUM, TEMP, POINT_NUM
	INTEGER :: I,J,K, I1,I2, FACE_INDEX, IDX
	INTEGER, ALLOCATABLE :: FACE_IDX(:), NUM(:)
	REAL(8), ALLOCATABLE :: FACE_AREA(:), POINT_NEIGHBOR(:,:)
	REAL(8) :: TIME_STEP
	REAL(8) :: POINT(3,3), TEMPPOINT(3), TEMP_POINT(3)
    REAL(8) :: W(3), V1(3), V2(3), V3(3), W1(3), W2(3)
	REAL(8) :: AREA, L1, L2
	REAL(8) :: TEMPVEC(3)
	REAL(8), ALLOCATABLE :: NORMAL(:,:), R1(:,:), MASS_CENTER(:,:)
	REAL(8) :: AREA_SUM
	INTEGER :: RIDGE_NUM, FACEIDX
	REAL(8) :: NEIGHBOR_RIDGE_POINT(3,2)
    
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF

        ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))        

	FACE_AREA = 0.
	POINT = 0.

	!COMPUTING AREA OF QUAD ELEMENT(INCLUDING NON-COPLANAR CASE)
	DO I = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
	    POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,I))
	    POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,I))
	    POINT(:,3) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,I))
        
        W1 = POINT(:,2) - POINT(:,1)
        W2 = POINT(:,3) - POINT(:,1)
        CALL VEC_CURL1(W1,W2,TEMPVEC)
        FACE_AREA(I) = SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))/2.

    END DO
    
    

        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        NORMAL = 0.
        !COMPUTING NORMALS
        DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
            AREA_SUM = 0.
            DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                AREA_SUM = AREA_SUM + FACE_AREA(IDX)
                DO K = 1, 3
                    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,IDX))
                    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,IDX))
                    V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,IDX))
                    W1 = V2 - V1
                    W2 = V3 - V1
                    CALL VEC_CURL1(W1,W2,TEMPVEC)
                    NORMAL(:,I) = NORMAL(:,I) + FACE_AREA(IDX)*TEMPVEC
                END DO
            END DO
            NORMAL(:,I) = NORMAL(:,I)/AREA_SUM
            NORMAL(:,I) = NORMAL(:,I)/SQRT(DOT_PRODUCT(NORMAL(:,I),NORMAL(:,I)))
        END DO

	!APPROXIMATING THE MEAN CURVATURE TERM AND THE TANGENT TERM

	ALLOCATE(R1(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(MASS_CENTER(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))

	R1 = 0.
	MASS_CENTER = 0.
	NUM = 0
	
    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        IF(SURFACE_CURRENT%POINT_TYPE(I)==1 .OR. SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==4) THEN
	    NUM(I) = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
        ALLOCATE(POINT_NEIGHBOR(3,NUM(I)))

       AREA_SUM = 0.
        POINT_NEIGHBOR = 0.

	    DO J = 1, NUM(I)
            FACE_INDEX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            AREA = FACE_AREA(FACE_INDEX)
		    AREA_SUM = AREA_SUM + FACE_AREA(FACE_INDEX)
		    
            DO K = 1, 3
		        TEMP = SURFACE_CURRENT%SURFACE_FACES(K,FACE_INDEX)
		        IF(TEMP==I) THEN
			        IDX = K
			    EXIT
		        END IF
            END DO
		
            IF(IDX==1) THEN
		        I1 = 2
		        I2 = 3
		    ELSEIF(IDX==2) THEN
		        I1 = 3
		        I2 = 1
		    ELSE
		        I1 = 1
		        I2 = 2
            END IF
            
            TEMPPOINT = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(IDX,FACE_INDEX))
                              
            POINT_NEIGHBOR(:,J) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(I1,FACE_INDEX))
		   
            POINT_NEIGHBOR(:,MOD(J,NUM(I))+1) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(I2,FACE_INDEX))

            MASS_CENTER(:,I) = MASS_CENTER(:,I) + (TEMPPOINT+POINT_NEIGHBOR(:,J)+POINT_NEIGHBOR(:,MOD(J,NUM(I))+1))*AREA/3.
                
        END DO
        
        MASS_CENTER(:,I) = MASS_CENTER(:,I)/AREA_SUM
        R1(:,I) = R1(:,I) + (MASS_CENTER(:,I)-TEMPPOINT)-DOT_PRODUCT(NORMAL(:,I),MASS_CENTER(:,I)-TEMPPOINT)*NORMAL(:,I)     

        DEALLOCATE(POINT_NEIGHBOR)
	END IF

	IF(SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==4) THEN        
	    RIDGE_NUM = 0
	    NEIGHBOR_RIDGE_POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
	    NEIGHBOR_RIDGE_POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,I)

	    DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
	    FACEIDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
	        DO K = 1, 3
		    IF( SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,FACEIDX)>0 .AND. ((SURFACE_CURRENT%SURFACE_FACES(K,FACEIDX).EQ.I) .OR. (SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,FACEIDX).EQ. I))) THEN
			IF(SURFACE_CURRENT%SURFACE_FACES(K,FACEIDX) .EQ. I) THEN
			    TEMP_POINT = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,FACEIDX))
			ELSE
			    TEMP_POINT = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K,FACEIDX))					
			END IF

		        IF(DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1))>MINERROR .AND. DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2))>MINERROR) THEN
		            RIDGE_NUM = RIDGE_NUM + 1
		            NEIGHBOR_RIDGE_POINT(:,RIDGE_NUM) = TEMP_POINT
		            EXIT
		        END IF
		    END IF
	        END DO
	        IF(RIDGE_NUM == 2) EXIT
	    END DO

	    IF(RIDGE_NUM < 2) THEN
	        WRITE(*,*) 'END OF THE RIDGE FOUND IN GEOMETRIC SMOOTHING'
	        WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,1)
	        WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,2)
	        WRITE(*,*) 'INDICES : ', I, J
	    END IF

	    V1 = NEIGHBOR_RIDGE_POINT(:,1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
	    L1 = SQRT(DOT_PRODUCT(V1,V1))
	    V2 = -(NEIGHBOR_RIDGE_POINT(:,2) - SURFACE_CURRENT%SURFACE_POINTS(:,I))
	    L2 = SQRT(DOT_PRODUCT(V2,V2))        

	    W = L1*V1 + L2*V2
	    W = W/SQRT(DOT_PRODUCT(W,W))
	    IF(DOT_PRODUCT(R1(:,I),W)<0) THEN
		W = -1.*W
	    END IF
	    R1(:,I) = DOT_PRODUCT(R1(:,I),W)*W
	END IF
    END DO
      
    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
       SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + 1/10.*R1(:,I)
    END DO
    
    DEALLOCATE(FACE_AREA)        
    DEALLOCATE(R1)
    DEALLOCATE(MASS_CENTER)
    DEALLOCATE(NORMAL)
    DEALLOCATE(NUM)

    END SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TRIANGLE
    
    
    SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        
        
        !CALL BOUNDARY_DIVIDING(TYP)
        
        CALL NEW_MODIFIED_NULLSPACE_SMOOTHING(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA, SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH, SURFACE_CURRENT%POINT_TYPE, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)
        
    END SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP
    
    
    
    SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, TEMP_NEWEDGELENGTH, TEMPPOINT_TYPE, DIVIDED_BOUNDARY_ARRAY)
	IMPLICIT NONE
        INTEGER :: TEMP_POINT_NUM
        REAL(8) :: TEMPPOINT(:,:)
        INTEGER :: TEMP_FACE_NUM
        INTEGER :: TEMPFACE(:,:)
        
        INTEGER :: TEMP_CONNECTION(:,:)
        INTEGER :: TEMP_CONNECTION_NUM(:)
        REAL(8) :: TEMP_NEWFACEAREA(:)
        REAL(8) :: TEMP_NEWEDGELENGTH(:,:)
        INTEGER :: TEMPPOINT_TYPE(:)
        INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
        
        
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        INTEGER :: I,J,K,L
        INTEGER :: I1,I2,I3, CON_NUM
        REAL(8) :: V1(3),V2(3)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        !! MODIFIED
        INTEGER :: LOCAL_SHAPE, TEMP_I, JMIN
	REAL(8) :: THETA_A, PHI_R, PHI_C, CHI_R, CHI_C
        !! END MODIFIED
        REAL(8), ALLOCATABLE :: N(:,:), W(:), ORIGIN_W(:), C(:,:), FACE_CENTER(:,:), FACE_AREA(:), T(:,:)
        REAL(8) :: CC(3)
        INTEGER :: RIDGE_EDGE_NUM, RIDGE_EDGE(2,10)
        
        REAL(8) :: W_SUM, ORIGIN_W_SUM
	REAL(8) :: R

        
        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
        
        REAL(8) :: TT(3,3)
        
        
        ALLOCATE(DISPLACEMENT(3,TEMP_POINT_NUM))
        ALLOCATE(FACE_AREA(TEMP_FACE_NUM))        
        ALLOCATE(FACE_CENTER(3,TEMP_FACE_NUM))
        ALLOCATE(NORMAL(3,TEMP_FACE_NUM))
        
        DO I=1,TEMP_FACE_NUM           
            I1 = TEMPFACE(1,I)
            I2 = TEMPFACE(2,I)
            I3 = TEMPFACE(3,I)
    
            V1 = TEMPPOINT(:,I2) - TEMPPOINT(:,I1)
            V2 = TEMPPOINT(:,I3) - TEMPPOINT(:,I1)    

            FACE_CENTER(:,I) = (TEMPPOINT(:,I1) + TEMPPOINT(:,I2) + TEMPPOINT(:,I3))/3.
    
            CALL VEC_CURL1(V1,V2, NORMAL(:,I))
    
            R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
            FACE_AREA(I) = R/2.  
            NORMAL(:,I) = NORMAL(:,I) / R       
        END DO
        
        DO I=1,TEMP_POINT_NUM

            CON_NUM = TEMP_CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))
            ALLOCATE(ORIGIN_W(CON_NUM))
            ALLOCATE(C(3,CON_NUM))
            
            W_SUM = 0.           
	    ORIGIN_W_SUM = 0.
            THETA_A = 0.

            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(TEMP_CONNECTION(J,I))             
                I1 = TEMPFACE(1,TEMP_CONNECTION(J,I))
                I2 = TEMPFACE(2,TEMP_CONNECTION(J,I))
                I3 = TEMPFACE(3,TEMP_CONNECTION(J,I))
                
                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF
                
                V1 = TEMPPOINT(:,I2) - TEMPPOINT(:,I1)
                V2 = TEMPPOINT(:,I3) - TEMPPOINT(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,TEMP_CONNECTION(J,I))
                W(J) = FACE_AREA(TEMP_CONNECTION(J,I)) / W_SUM
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            THETA_A = THETA_A - 2.*PI
        
            PHI_R = 14. * PI/180.
            PHI_C = 45. * PI/180.
            
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF
            
            LOCAL_SHAPE = TEMPPOINT_TYPE(I)
            
            RIDGE_EDGE_NUM = 0
            
            DO J=1,CON_NUM
                L = TEMP_CONNECTION(J,I)
                DO K=1,3
                    IF(TEMPFACE(K,L)==I) THEN
                        EXIT
                    END IF
                END DO
                
                IF(DIVIDED_BOUNDARY_ARRAY(K,L) .NE. 0) THEN
                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = K
                    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = L
                END IF
            END DO
            
            IF(RIDGE_EDGE_NUM > 2 .OR. RIDGE_EDGE_NUM == 1) THEN
                CC(:) = 0.
            ELSE IF(RIDGE_EDGE_NUM == 0) THEN
                DO J = 1,CON_NUM
                    ORIGIN_W_SUM = ORIGIN_W_SUM + 1./TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I))
                END DO
                
                DO J = 1,CON_NUM
                    ORIGIN_W(J) = (1./TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I)))/ORIGIN_W_SUM
                    C(:,J) = FACE_CENTER(:,TEMP_CONNECTION(J,I)) - TEMPPOINT(:,I)
                END DO
                
                CC(:) = 0.
                DO J = 1,CON_NUM
                    CC(:) = CC(:) + W(J) * C(:,J)/3.
                END DO
            ELSE IF(RIDGE_EDGE_NUM == 2 .AND. DIVIDED_BOUNDARY_ARRAY(RIDGE_EDGE(1,1), RIDGE_EDGE(2,1)) == DIVIDED_BOUNDARY_ARRAY(RIDGE_EDGE(1,2) , RIDGE_EDGE(2,2)) ) THEN
                DO J = 1,2
                    ORIGIN_W_SUM = ORIGIN_W_SUM + 1./TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J))
                END DO
                
                DO J = 1,2
                    ORIGIN_W(J) = (1./TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J)))/ORIGIN_W_SUM
                    I1 = TEMPFACE(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J))
                    I2 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1, RIDGE_EDGE(2,J))
                    C(:,J) = (TEMPPOINT(:,I1)+TEMPPOINT(:,I2))/2. - TEMPPOINT(:,I)
                END DO
                
                CC(:) = 0.
                DO J = 1,2
                    CC(:) = CC(:) + ORIGIN_W(J) * C(:,J)/3.
                END DO
            ELSE
                CC(:) = 0.
            END IF
            
            IF(TEMPPOINT_TYPE(I)==5) THEN
                TT(:,:) = 0.
            ELSE IF(TEMPPOINT_TYPE(I)==4) THEN
                
                ALLOCATE(T(3,1))
                
                K = 0
                DO J=1,RIDGE_EDGE_NUM
                    IF(TEMPPOINT_TYPE(TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1,RIDGE_EDGE(2,J)))>=4) THEN
                        K = K + 1
                        IF(K==1) THEN
                            I1 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1,RIDGE_EDGE(2,J))
                        ELSE
                            I2 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1,RIDGE_EDGE(2,J))
                            EXIT
                        END IF
                    END IF
                END DO
                
                T(:,1) = TEMPPOINT(:,I1) - TEMPPOINT(:,I2)
                
                DO K=1,3
                    DO L=1,3
                        TT(K,L) = TT(K,L) + T(K,1)*T(L,1)
                    END DO
                END DO
                
                DEALLOCATE(T)
                
            ELSE IF(LOCAL_SHAPE .NE. 3) THEN
                
                ALLOCATE(T(3,3-LOCAL_SHAPE))
                
                DO J = LOCAL_SHAPE+1, 3
                    T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
                END DO
                
                DO K=1,3
                    DO L=1,3
                        TT(K,L) = 0.
                        DO J=1,3-LOCAL_SHAPE
                            TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
                        END DO
                    END DO
                END DO
                
                DEALLOCATE(T)
            ELSE
                TT(:,:) = 0.
            END IF
            
            DISPLACEMENT(:,I) = 0.
            
            DO K = 1,3
                DO L = 1,3
                    DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + TT(K,L)*CC(L)
                END DO
            END DO
            
            DEALLOCATE(N)
            DEALLOCATE(W)
	    DEALLOCATE(ORIGIN_W)
            DEALLOCATE(C)
            
        END DO
        
       ! CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TEMP_POINT_NUM
            IF(TEMPPOINT_TYPE(I) == 3) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO

        DO I = 1,TEMP_POINT_NUM
            TEMPPOINT(:,I) = TEMPPOINT(:,I) + DISPLACEMENT(:,I)
        END DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)  
        DEALLOCATE(FACE_CENTER)
        
        DEALLOCATE(DISPLACEMENT)
        
        
    END SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING

    SUBROUTINE FACEOFFSETTING_3D(TYP, TIMESTEP)
        IMPLICIT NONE
        INTEGER :: TYP
        REAL(8) :: TIMESTEP
        INTEGER :: I
        REAL(8) :: AXIS(3)

        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
      
        CALL WAVEFRONT_DISPLACEMENT(TYP, TIMESTEP)
 
    END SUBROUTINE FACEOFFSETTING_3D
    
    RECURSIVE SUBROUTINE FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, CURRENT_POINT, DIR)
	IMPLICIT NONE
        INTEGER :: FACE_NUM
        INTEGER :: FACE(:,:)
        INTEGER :: CONNECTION_NUM(:)
        INTEGER :: CONNECTION(:,:)
        
        INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
        INTEGER :: RIDGE_FLAG
        INTEGER :: RIDGE(:)
        INTEGER :: RIDGE_NUM
        
        LOGICAL :: USED_POINT(:)
        
        INTEGER :: CURRENT_POINT
        INTEGER :: DIR
        
        INTEGER :: NUM, I, J, K, J1, J2
        
        USED_POINT(CURRENT_POINT) = .TRUE.
        
        NUM = 0
        
        DO K=1,CONNECTION_NUM(CURRENT_POINT)
            I = CONNECTION(K,CURRENT_POINT)
            DO J=1,3
                IF(FACE(J,I)==CURRENT_POINT) THEN
                    EXIT
                END IF
            END DO
            
            IF(DIVIDED_BOUNDARY_ARRAY(J,I)==RIDGE_FLAG .AND. .NOT. USED_POINT(FACE(MOD(J,3)+1,I))) THEN
                NUM = NUM + 1
                IF(NUM==1) THEN
                    J1 = FACE(MOD(J,3)+1,I)
                ELSE
                    J2 = FACE(MOD(J,3)+1,I)
                END IF
            END IF
        END DO
        
        IF(DIR==0) THEN
            
            CALL FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, J1, -1)
            
            RIDGE_NUM = RIDGE_NUM + 1
            RIDGE(RIDGE_NUM) = CURRENT_POINT
            
            IF(NUM>=2) THEN
                CALL FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, J2, 1)
            END IF
            
        ELSE IF(DIR==-1) THEN
            
            IF(NUM>=1) THEN
                CALL FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, J1, -1)
            END IF
            
            RIDGE_NUM = RIDGE_NUM + 1
            RIDGE(RIDGE_NUM) = CURRENT_POINT
            
        ELSE IF(DIR==1) THEN
            
            RIDGE_NUM = RIDGE_NUM + 1
            RIDGE(RIDGE_NUM) = CURRENT_POINT
            
            IF(NUM>=1) THEN
                CALL FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, J2, 1)
            END IF
            
        END IF
        
    END SUBROUTINE FIND_RIDGE_ARRAY_RECURSIVE
    
    SUBROUTINE FIND_RIDGE_ARRAY(TYP, RIDGE_FLAG, RIDGE, RIDGE_NUM)
        IMPLICIT NONE
        INTEGER :: TYP
        INTEGER :: RIDGE_FLAG
        INTEGER :: RIDGE(:)
        INTEGER :: RIDGE_NUM
        
        INTEGER :: CURRENT_POINT
        LOGICAL, ALLOCATABLE :: USED_POINT(:)
        
        INTEGER :: I,K
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        RIDGE_NUM = 0
        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            DO K=1,3
                IF(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,I)==RIDGE_FLAG) THEN
                    CURRENT_POINT = SURFACE_CURRENT%SURFACE_FACES(K,I)
                    EXIT
                END IF
            END DO
        END DO
        
        ALLOCATE(USED_POINT(SURFACE_CURRENT%SURFACE_POINTS_NUM))
        USED_POINT(:) = .FALSE.
        
        CALL FIND_RIDGE_ARRAY_RECURSIVE(SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, CURRENT_POINT, 0)
        
        DEALLOCATE(USED_POINT)
        
    END SUBROUTINE FIND_RIDGE_ARRAY
    
    SUBROUTINE ATTACH_TWO_RIDGES(FLUID_RIDGE_FLAG, CASE_RIDGE_FLAG)
        IMPLICIT NONE
        INTEGER :: FLUID_RIDGE_FLAG
        INTEGER :: CASE_RIDGE_FLAG
        INTEGER, ALLOCATABLE :: FLUID_RIDGE(:)
        INTEGER, ALLOCATABLE :: CASE_RIDGE(:)
        INTEGER :: FLUID_RIDGE_NUM
        INTEGER :: CASE_RIDGE_NUM
        
        ALLOCATE(FLUID_RIDGE(SURFACE_FLUID%SURFACE_POINTS_NUM))
        ALLOCATE(CASE_RIDGE(SURFACE_CASE%SURFACE_POINTS_NUM))
        
        CALL FIND_RIDGE_ARRAY(0, FLUID_RIDGE_FLAG, FLUID_RIDGE, FLUID_RIDGE_NUM)
        CALL FIND_RIDGE_ARRAY(2, CASE_RIDGE_FLAG, CASE_RIDGE, CASE_RIDGE_NUM)
        
        DEALLOCATE(FLUID_RIDGE)
        DEALLOCATE(CASE_RIDGE)
        
    END SUBROUTINE ATTACH_TWO_RIDGES

    SUBROUTINE MAINTAIN_CASE_CORNER()
        IMPLICIT NONE
        INTEGER :: I, J, K, I1
        INTEGER :: JMIN
        REAL(8) :: R, RMIN
        LOGICAL :: B, C
        
        DO I = 1,SURFACE_CASE%SURFACE_POINTS_NUM
            IF(SURFACE_CASE%POINT_TYPE(I)==3) THEN
                B = .TRUE.
                DO J=1,SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I)
                    I1 = SURFACE_CASE%POINT_FACE_CONNECTION(J,I)
                    IF(SURFACE_CASE%FACE_ONINTERFACE(I1) .NE. 0) THEN
                        B = .FALSE.
                    END IF
                END DO
                IF(B) THEN
                    RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
                    JMIN = 0
                    DO J = 1,SURFACE_FLUID%SURFACE_POINTS_NUM
                        C = .FALSE.
                        DO K = 1,SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I)
                            IF(SURFACE_FLUID%POINT_RELATEDFACE(2+1,J)==SURFACE_CASE%POINT_FACE_CONNECTION(K,I)) THEN
                                C = .TRUE.
                            END IF
                        END DO
                        IF(SURFACE_FLUID%POINT_TYPE(J) .NE. 4 .AND. C) THEN
                            R = SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,J), SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,J) ))
                            IF(R<RMIN) THEN
                                RMIN = R
                                JMIN = J
                            END IF
                        END IF
                    END DO
                    IF(JMIN.NE.0) THEN
                        SURFACE_FLUID%SURFACE_POINTS(:,JMIN) = SURFACE_CASE%SURFACE_POINTS(:,I)
                    END IF
                END IF
            END IF
        END DO
    
    END SUBROUTINE MAINTAIN_CASE_CORNER
    
    SUBROUTINE GENERATE_FACES_CASE(POINT_NUM, POINT, FACE_NUM, FACE, NEW_FACE)
        IMPLICIT NONE
        INTEGER :: POINT_NUM
        REAL(8) :: POINT(3,POINT_NUM)
        INTEGER :: FACE_NUM
        INTEGER :: FACE(4,FACE_NUM)
        INTEGER :: NEW_FACE(3,2*FACE_NUM)
        
        INTEGER :: I
        REAL(8) :: V1(3),V2(3),V3(3),V4(3), R1, R2
        REAL(8) :: S, F_SIZE_SHAPE, F_SIZE, F_SHAPE, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW, F_SIZE_SHAPE1_NEW, F_SIZE1_NEW, F_SHAPE1_NEW, QUALITY_BEFORE, QUALITY_AFTER, N(3), N1(3), N_AVG(3), N_NEW(3), N1_NEW(3)
        
        
        DO I=1,FACE_NUM
            V1 = POINT(:,FACE(1,I))
            V2 = POINT(:,FACE(2,I))
            V3 = POINT(:,FACE(3,I))
            V4 = POINT(:,FACE(4,I))
            
            R1 = SQRT(DOT_PRODUCT(V3-V1,V3-V1))
            R2 = SQRT(DOT_PRODUCT(V4-V2,V4-V2))
            
            S = 1.
            
            CALL MESH_QUALITY_TRIANGLE_ONE(V1,V2,V3, S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
            CALL MESH_QUALITY_TRIANGLE_ONE(V1,V3,V4, S, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1)
            
            CALL TRIANGLE_NORMAL(V1,V2,V3, N)
            CALL TRIANGLE_NORMAL(V1,V3,V4, N1)
            
            CALL MESH_QUALITY_TRIANGLE_ONE(V2,V3,V4, S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
            CALL MESH_QUALITY_TRIANGLE_ONE(V2,V4,V1, S, F_SIZE_SHAPE1_NEW, F_SIZE1_NEW, F_SHAPE1_NEW)
            
            CALL TRIANGLE_NORMAL(V2,V3,V4, N_NEW)
            CALL TRIANGLE_NORMAL(V2,V4,V1, N1_NEW)
            
            IF(DOT_PRODUCT(N,N1)>0) THEN
                N_AVG = N+N1
                N_AVG = N_AVG/SQRT(DOT_PRODUCT(N_AVG,N_AVG))
            ELSE
                N_AVG = N_NEW+N1_NEW
                N_AVG = N_AVG/SQRT(DOT_PRODUCT(N_AVG,N_AVG))
            END IF
            
            IF(DOT_PRODUCT(N, N_AVG) < 0) THEN
                F_SHAPE = 0.
            END IF
            
            IF(DOT_PRODUCT(N1, N_AVG) < 0) THEN
                F_SHAPE1 = 0.
            END IF
            
            IF(DOT_PRODUCT(N_NEW, N_AVG) < 0) THEN
                F_SHAPE_NEW = 0.
            END IF
            
            IF(DOT_PRODUCT(N1_NEW, N_AVG) < 0) THEN
                F_SHAPE1_NEW = 0.
            END IF
            
            QUALITY_BEFORE = 1./(F_SHAPE+MINERROR) + 1./(F_SHAPE1+MINERROR)
            QUALITY_AFTER = 1./(F_SHAPE_NEW+MINERROR) + 1./(F_SHAPE1_NEW+MINERROR)
            
            IF(QUALITY_BEFORE < QUALITY_AFTER) THEN !IF(R1<R2) THEN
                NEW_FACE(1,2*I-1) = FACE(3,I)
                NEW_FACE(2,2*I-1) = FACE(2,I)
                NEW_FACE(3,2*I-1) = FACE(1,I)
                
                NEW_FACE(1,2*I) = FACE(3,I)
                NEW_FACE(2,2*I) = FACE(1,I)
                NEW_FACE(3,2*I) = FACE(4,I)
                
                !NEW_FACE(1,2*I-1) = FACE(1,I)
                !NEW_FACE(2,2*I-1) = FACE(2,I)
                !NEW_FACE(3,2*I-1) = FACE(3,I)
                
                !NEW_FACE(1,2*I) = FACE(1,I)
                !NEW_FACE(2,2*I) = FACE(3,I)
                !NEW_FACE(3,2*I) = FACE(4,I)
            ELSE
                NEW_FACE(1,2*I-1) = FACE(4,I)
                NEW_FACE(2,2*I-1) = FACE(3,I)
                NEW_FACE(3,2*I-1) = FACE(2,I)
                
                NEW_FACE(1,2*I) = FACE(4,I)
                NEW_FACE(2,2*I) = FACE(2,I)
                NEW_FACE(3,2*I) = FACE(1,I)
                
                !NEW_FACE(1,2*I-1) = FACE(2,I)
                !NEW_FACE(2,2*I-1) = FACE(3,I)
                !NEW_FACE(3,2*I-1) = FACE(4,I)
                
                !NEW_FACE(1,2*I) = FACE(2,I)
                !NEW_FACE(2,2*I) = FACE(4,I)
                !NEW_FACE(3,2*I) = FACE(1,I)
            END IF
        END DO

    END SUBROUTINE GENERATE_FACES_CASE
    
    SUBROUTINE GENERATE_LOCATION_CASE(LOC_NUM, OLD_LOC, NEW_LOC)
        IMPLICIT NONE
        INTEGER :: LOC_NUM
        INTEGER :: OLD_LOC(LOC_NUM)
        INTEGER :: NEW_LOC(2*LOC_NUM)
        
        INTEGER :: I
        
        DO I=1,LOC_NUM
            NEW_LOC(2*I-1) = OLD_LOC(I)
            NEW_LOC(2*I) = OLD_LOC(I)
        END DO
    END SUBROUTINE GENERATE_LOCATION_CASE
    
    SUBROUTINE RESET_SURFACE(TYP, FLAG, POINT_NUM, FACE_NUM, SURFACE_POINTS, SURFACE_FACES, &
    SURFACE_INITIAL_FACE_AREA, SURFACE_INITIAL_EDGE_LENGTH, FACE_B_RATE, POINT_VELOCITY, POINT_DISPLACEMENT, &
    POINT_FACE_CONNECTION, POINT_FACE_CONNECTION_NUM, POINT_TYPE, FACE_LOCATION, FACE_ONINTERFACE, POINT_RELATEDPT, POINT_RELATEDFACE, FACE_PRESSURE, POINT_FORCE, POINT_DISTANCE, FACE_IMPACT_ZONE, FACE_ABLATION_FLAG, FACE_DIVIDED_REGION_ARRAY, FACE_DIVIDED_BOUNDARY_ARRAY)
	IMPLICIT NONE
        INTEGER :: TYP
        LOGICAL :: FLAG
        INTEGER :: POINT_NUM, FACE_NUM
        
        REAL(8), OPTIONAL :: SURFACE_POINTS(3,POINT_NUM)
        INTEGER, OPTIONAL :: SURFACE_FACES(:,:)
        
        REAL(8), OPTIONAL :: SURFACE_INITIAL_FACE_AREA(FACE_NUM)
        REAL(8), OPTIONAL :: SURFACE_INITIAL_EDGE_LENGTH(3,FACE_NUM)
        
        REAL(8), OPTIONAL :: FACE_B_RATE(FACE_NUM)
        REAL(8), OPTIONAL :: POINT_VELOCITY(3,POINT_NUM)
        REAL(8), OPTIONAL :: POINT_DISPLACEMENT(3,POINT_NUM)
        INTEGER, OPTIONAL :: POINT_FACE_CONNECTION(30,POINT_NUM)
        INTEGER, OPTIONAL :: POINT_FACE_CONNECTION_NUM(POINT_NUM)
        INTEGER, OPTIONAL :: POINT_TYPE(POINT_NUM)  
       
	INTEGER, OPTIONAL :: FACE_LOCATION(FACE_NUM)
        INTEGER, OPTIONAL :: FACE_ONINTERFACE(FACE_NUM)
        
        INTEGER, OPTIONAL :: POINT_RELATEDPT(3,POINT_NUM)
        INTEGER, OPTIONAL :: POINT_RELATEDFACE(3,POINT_NUM)
        
        REAL(8), OPTIONAL :: FACE_PRESSURE(FACE_NUM)
        REAL(8), OPTIONAL :: POINT_FORCE(3,POINT_NUM)
        REAL(8), OPTIONAL :: POINT_DISTANCE(3,POINT_NUM)
        
        INTEGER, OPTIONAL :: FACE_IMPACT_ZONE(3,FACE_NUM)
        INTEGER, OPTIONAL :: FACE_ABLATION_FLAG(FACE_NUM)
        
        INTEGER, OPTIONAL :: FACE_DIVIDED_REGION_ARRAY(FACE_NUM)
        INTEGER, OPTIONAL :: FACE_DIVIDED_BOUNDARY_ARRAY(3,FACE_NUM)
        
        INTEGER :: I, I1, I2, I3
        REAL(8) :: R, V1(3), V2(3), V3(3), N(3), L, R1, R2, R3, F_SIZE, F_SHAPE
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_POINTS)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_POINTS)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_FACES)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_FACES)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_INITIAL_MESH_QUALITY)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_MESH_QUALITY)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_B_RATE)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_B_RATE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_VELOCITY)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_VELOCITY)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_DISPLACEMENT)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_DISPLACEMENT)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_FACE_CONNECTION)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_TYPE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_TYPE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%INITIAL_POINT_TYPE)) THEN
            DEALLOCATE(SURFACE_CURRENT%INITIAL_POINT_TYPE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_LOCATION)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_LOCATION)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_ONINTERFACE)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_ONINTERFACE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_RELATEDPT)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_RELATEDPT)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_RELATEDFACE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_RELATEDFACE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_PRESSURE)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_PRESSURE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_FORCE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_FORCE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_DISTANCE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_DISTANCE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_IMPACT_ZONE)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_IMPACT_ZONE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_ABLATION_FLAG)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_ABLATION_FLAG)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)
        END IF

        IF(FLAG) THEN
            
            SURFACE_CURRENT%SURFACE_POINTS_NUM = POINT_NUM
            SURFACE_CURRENT%SURFACE_FACES_NUM = FACE_NUM
            
            ALLOCATE(SURFACE_CURRENT%SURFACE_POINTS(3,POINT_NUM))
            !IF(TYP==0) THEN
                ALLOCATE(SURFACE_CURRENT%SURFACE_FACES(3,FACE_NUM))
            !ELSE
            !    ALLOCATE(SURFACE_CURRENT%SURFACE_FACES(4,FACE_NUM))
            !END IF
            ALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(3,FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_B_RATE(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_VELOCITY(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_DISPLACEMENT(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION(30,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_TYPE(POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%INITIAL_POINT_TYPE(POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_LOCATION(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_ONINTERFACE(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_RELATEDPT(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_RELATEDFACE(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_PRESSURE(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_FORCE(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_DISTANCE(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_IMPACT_ZONE(3,FACE_NUM))
	    ALLOCATE(SURFACE_CURRENT%FACE_ABLATION_FLAG(FACE_NUM))
	    ALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(FACE_NUM))
	    ALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(3,FACE_NUM))
            IF(TYP .NE. 0) THEN
                ALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_MESH_QUALITY(FACE_NUM/2))
            END IF
            
            IF(PRESENT(SURFACE_POINTS)) THEN
                SURFACE_CURRENT%SURFACE_POINTS(:,:) = SURFACE_POINTS(:,:)
            END IF
            
            IF(PRESENT(SURFACE_FACES)) THEN
                SURFACE_CURRENT%SURFACE_FACES(:,:) = SURFACE_FACES(:,:)
            END IF
            
            IF(PRESENT(SURFACE_INITIAL_FACE_AREA)) THEN
                SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(:) = SURFACE_INITIAL_FACE_AREA(:)
                SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(:,:) = SURFACE_INITIAL_EDGE_LENGTH(:,:)
            ELSE
                SURFACE_CURRENT%MESH_SIZE = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
                SURFACE_CURRENT%MESH_SIZE_MAX = 0.
                
                !$OMP PARALLEL DO PRIVATE(I,R),REDUCTION(MIN:MESH_SIZE),REDUCTION(MAX:MESH_SIZE_MAX)
                DO I = 1, FACE_NUM
                    
                    I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
                    I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
                    I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
                    
                    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                    V3 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I3)
                    
                    CALL VEC_CURL1(V1,V2, N)
                    
                    R = SQRT(DOT_PRODUCT(N,N))/2
                
                    SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(I) = R
                    SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(1,I) = SQRT(DOT_PRODUCT(V1,V1))
                    SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(2,I) = SQRT(DOT_PRODUCT(V3,V3))
                    SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(3,I) = SQRT(DOT_PRODUCT(V2,V2))
                    
                    R1 = SQRT(DOT_PRODUCT(V1,V1))
                    R2 = SQRT(DOT_PRODUCT(V2,V2))
                    R3 = SQRT(DOT_PRODUCT(V3,V3))
                    L = (R1 + R2 + R3) / 3.
                    
                    IF(SURFACE_CURRENT%MESH_SIZE > L) THEN
                        SURFACE_CURRENT%MESH_SIZE = L
                    END IF
                    IF(SURFACE_CURRENT%MESH_SIZE_MAX < L) THEN
                        SURFACE_CURRENT%MESH_SIZE_MAX = L
                    END IF
                END DO
                !$OMP END PARALLEL DO
            END IF
            
            IF(TYP .NE. 0) THEN
                DO I=1,FACE_NUM/2
                    CALL MESH_QUALITY_SQUARE_ONE(SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,2*I-1)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,2*I-1)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,2*I-1)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,2*I)), SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I-1) + SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I),        SURFACE_CURRENT%SURFACE_INITIAL_MESH_QUALITY(I), F_SIZE, F_SHAPE)
                END DO
            END IF
            
            IF(PRESENT(FACE_B_RATE)) THEN
                SURFACE_CURRENT%FACE_B_RATE(:) = FACE_B_RATE(:)
            ELSE
                SURFACE_CURRENT%FACE_B_RATE(:) = 0.
            END IF
            
            IF(PRESENT(POINT_VELOCITY)) THEN
                SURFACE_CURRENT%POINT_VELOCITY(:,:) = POINT_VELOCITY(:,:)
            ELSE
                SURFACE_CURRENT%POINT_VELOCITY(:,:) = 0.
            END IF
            
            IF(PRESENT(POINT_DISPLACEMENT)) THEN
                SURFACE_CURRENT%POINT_DISPLACEMENT(:,:) = POINT_DISPLACEMENT(:,:)
            ELSE
                SURFACE_CURRENT%POINT_DISPLACEMENT(:,:) = 0.
            END IF
            
            IF(PRESENT(POINT_FACE_CONNECTION)) THEN
                SURFACE_CURRENT%POINT_FACE_CONNECTION(:,:) = POINT_FACE_CONNECTION(:,:)
                SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(:) = POINT_FACE_CONNECTION_NUM(:)
            ELSE
                CALL POINT_FACE_CONNECTING_TYPE(TYP)
            END IF
            
            IF(PRESENT(FACE_LOCATION)) THEN
                SURFACE_CURRENT%FACE_LOCATION(:) = FACE_LOCATION(:)
	        CALL FIND_PATCH_NUM(TYP)
	        ALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_CURRENT%SURFACE_PATCHES_NUM))
            ELSE
		CALL FIND_PATCH_NUM(TYP)
	        ALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_CURRENT%SURFACE_PATCHES_NUM)) 
                SURFACE_CURRENT%FACE_LOCATION(:) = -1
            END IF
            IF(PRESENT(POINT_DISTANCE)) THEN
                SURFACE_CURRENT%POINT_DISTANCE(:,:) = POINT_DISTANCE(:,:)
            ELSE
                SURFACE_CURRENT%POINT_DISTANCE(:,:) = 0.
            END IF
            
            IF(PRESENT(FACE_ONINTERFACE)) THEN
                SURFACE_CURRENT%FACE_ONINTERFACE(:) = FACE_ONINTERFACE(:)
            ELSE
               !CALL FIND_INTERFACE(TYP,2)
                SURFACE_CURRENT%FACE_ONINTERFACE(:) = -1
            END IF
            
            IF(PRESENT(POINT_RELATEDPT)) THEN
                SURFACE_CURRENT%POINT_RELATEDPT(:,:) = POINT_RELATEDPT(:,:)
            ELSE
                SURFACE_CURRENT%POINT_RELATEDPT(:,:) = 0
            END IF
            
            IF(PRESENT(POINT_RELATEDFACE)) THEN
                SURFACE_CURRENT%POINT_RELATEDFACE(:,:) = POINT_RELATEDFACE(:,:)
            ELSE
                SURFACE_CURRENT%POINT_RELATEDFACE(:,:) = 0
            END IF
            IF(PRESENT(FACE_PRESSURE)) THEN
                SURFACE_CURRENT%FACE_PRESSURE(:) = FACE_PRESSURE(:)
            ELSE
                SURFACE_CURRENT%FACE_PRESSURE(:) = 0.
            END IF
            IF(PRESENT(POINT_FORCE)) THEN
                SURFACE_CURRENT%POINT_FORCE(:,:) = POINT_FORCE(:,:)
            ELSE
                SURFACE_CURRENT%POINT_FORCE(:,:) = 0.
            END IF           
            IF(PRESENT(FACE_IMPACT_ZONE)) THEN
                SURFACE_CURRENT%FACE_IMPACT_ZONE(:,:) = FACE_IMPACT_ZONE(:,:)
            ELSE
                SURFACE_CURRENT%FACE_IMPACT_ZONE(:,:) = 0
            END IF
            
            IF(PRESENT(POINT_TYPE)) THEN
                SURFACE_CURRENT%POINT_TYPE(:) = POINT_TYPE(:)
                SURFACE_CURRENT%INITIAL_POINT_TYPE(:) = POINT_TYPE(:)
            ELSE
                CALL FIND_POINT_TYPE(TYP)
                SURFACE_CURRENT%INITIAL_POINT_TYPE(:) = SURFACE_CURRENT%POINT_TYPE(:)
            END IF
	    IF(TYP == 0 .OR. TYP == 1) THEN
                SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(:) = 0
	    END IF

            IF(PRESENT(FACE_ABLATION_FLAG)) THEN
                SURFACE_CURRENT%FACE_ABLATION_FLAG(:) = FACE_ABLATION_FLAG(:)
            ELSE
                SURFACE_CURRENT%FACE_ABLATION_FLAG(:) = 0
            END IF

            IF(PRESENT(FACE_DIVIDED_REGION_ARRAY)) THEN
                SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(:) = FACE_DIVIDED_REGION_ARRAY(:)
            ELSE
                SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(:) = 0
            END IF

            IF(PRESENT(FACE_DIVIDED_BOUNDARY_ARRAY)) THEN
                SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,:) = FACE_DIVIDED_BOUNDARY_ARRAY(:,:)
            ELSE
                SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,:) = 0
            END IF
            
        END IF
    END SUBROUTINE RESET_SURFACE
END MODULE PROPA_RECONST_REINITIAL_3D
