MODULE PROPA_RECONST_REINITIAL_3D
    USE SURFACE_MODULE_3D
    USE SURFACES_3D
    USE OPERATORS_3D
    USE EXTRAPOLATION_3D
    USE SVD
    IMPLICIT NONE
    
    CONTAINS 
    SUBROUTINE INTERPOLATE_FLUID_DISPLACEMENT(TYP1_POINT_NUM, TYP1_POINT, TYP1_POINTLOC, DATA_DISPLACEMENT)
        
	IMPLICIT NONE
    
        INTEGER :: I
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8) :: TYP1_POINT(:,:)
        INTEGER :: TYP1_POINTLOC(:,:)
        
        INTEGER :: TYP2_POINT_NUM
        REAL(8), POINTER, DIMENSION(:,:) :: TYP2_POINT
        INTEGER, POINTER, DIMENSION(:,:) :: TYP2_POINTLOC
        
        REAL(8) :: DATA_DISPLACEMENT(:,:)
        
        REAL(8), ALLOCATABLE :: CR_SOURCE(:,:), CR_TARGET(:,:)
        
        !CALL UPDATE_INTERFACE_CLUSTER(0)
        
        TYP2_POINT_NUM = INTERFACE_FLUID_POINTS_NUM
        TYP2_POINT => INTERFACE_FLUID_POINTS
        TYP2_POINTLOC => INTERFACE_FLUID_POINTS_LOC
        
        ALLOCATE(CR_SOURCE(3,TYP1_POINT_NUM))
        
	!$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP1_POINT_NUM
            CR_SOURCE(:,I) = DATA_DISPLACEMENT(:,TYP1_POINTLOC(1,I))
        END DO
        !$OMP END PARALLEL DO
        
        ALLOCATE(CR_TARGET(3,TYP2_POINT_NUM))
        
        !CALL DATA_TRANSFER(TYP1_POINT_NUM, TYP1_POINT, CR_SOURCE(1,:), TYP2_POINT_NUM, TYP2_POINT, CR_TARGET(1,:))
        !CALL DATA_TRANSFER(TYP1_POINT_NUM, TYP1_POINT, CR_SOURCE(2,:), TYP2_POINT_NUM, TYP2_POINT, CR_TARGET(2,:))
        !CALL DATA_TRANSFER(TYP1_POINT_NUM, TYP1_POINT, CR_SOURCE(3,:), TYP2_POINT_NUM, TYP2_POINT, CR_TARGET(3,:))
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP2_POINT_NUM
            SURFACE_FLUID%POINT_DISPLACEMENT(:,TYP2_POINTLOC(1,I)) = CR_TARGET(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        DEALLOCATE(CR_SOURCE)
        DEALLOCATE(CR_TARGET)
        
    END SUBROUTINE INTERPOLATE_FLUID_DISPLACEMENT
    
    SUBROUTINE FLUID_MOVE(TIME_STEP) ! TYP = 0 or 1, TYP2 = 0
	IMPLICIT NONE
        REAL(8) :: TIME_STEP
        INTEGER :: I, IDX, IDX2, L, M 
	INTEGER, ALLOCATABLE :: RIDGE_EDGE(:,:)
        INTEGER :: RIDGE_EDGE_NUM, NUM, FACE_INDEX
	REAL(8) :: DIST, DIST1, DIST2, DIST3, TEMPDIST, POINTDIST
	REAL(8) :: A1(3), A2(3), T(3), INNER, INNER2, R
	LOGICAL :: FLAG

!    write(*,*) 'fluid 3308:', surface_fluid%surface_points(:,3308)
        CALL FACEOFFSETTING_3D(0,TIME_STEP)

        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
            SURFACE_FLUID%SURFACE_POINTS(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,I) + SURFACE_FLUID%POINT_VELOCITY(:,I)
        END DO
!   write(*,*) 'fluid 3308:', surface_fluid%surface_points(:,3308)
        !$OMP END PARALLEL DO
        CALL UPDATE_RELATEDFACE(0,2,.FALSE.)
!   write(*,*) 'fluid 3308:', surface_fluid%surface_points(:,3308)    
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
            IF(SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)==0) THEN
                SURFACE_PROPEL%POINT_VELOCITY(:,I) = 0.
            ELSE
		IF(SURFACE_PROPEL%INITIAL_POINT_TYPE(I)==5) THEN
		    IDX2 = SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)
		    IF(SURFACE_FLUID%POINT_TYPE(IDX2) == 5) THEN
		        SURFACE_PROPEL%POINT_VELOCITY(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)) - SURFACE_PROPEL%SURFACE_POINTS(:,I)
		    ELSEIF(SURFACE_FLUID%POINT_TYPE(IDX2) == 4) THEN
		        CALL NEIGHBOR_RIDGE_PROJECTION(1,I,0,4)
		    ELSE
		        WRITE(*,*) 'ERROR : POINT TYPE MISMATCH, FLUID RELATED PT TYPE IS NOT 4 OR 5.'
		    END IF
		ELSEIF(SURFACE_PROPEL%INITIAL_POINT_TYPE(I)==4) THEN
                
		CALL NEIGHBOR_RIDGE_PROJECTION(1,I,0,4)
            
                ELSEIF(SURFACE_PROPEL%INITIAL_POINT_TYPE(I)==3) THEN
                    IDX = SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)
  	            IF(SURFACE_FLUID%POINT_TYPE(IDX) == 3) THEN
	                SURFACE_PROPEL%POINT_VELOCITY(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)) - SURFACE_PROPEL%SURFACE_POINTS(:,I)         
	            ELSE
	                CALL NEIGHBOR_RIDGE_PROJECTION(1,I,0,2)
	            END IF
                END IF
	    END IF
        END DO

        !$OMP END PARALLEL DO
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
            SURFACE_PROPEL%SURFACE_POINTS(:,I) = SURFACE_PROPEL%SURFACE_POINTS(:,I) + SURFACE_PROPEL%POINT_VELOCITY(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        FLAG = .TRUE.
        CALL UPDATE_CASE_INTERFACE(FLAG)
        IF(FLAG) THEN
	    !CALL FIND_INTERFACE_CLUSTER(0)
            !CALL FIND_INTERFACE_CLUSTER(1)
        END IF
        
	DO I=1,10
	    CALL GEOMETRIC_FLOW_SMOOTHING(1,TIME_STEP)
	END DO
	!DO I = 1,10
        !CALL NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(1)
	!END DO
	!CALL SQUARE_NULLSPACE_SMOOTHING(1)
	!DO I = 1,100
	!    CALL GEOMETRIC_FLOW_SMOOTHING(1,TIME_STEP)
	!END DO
        !CALL UPDATE_RELATEDFACE(1,2)
        
        !CALL MAINTAIN_CASE_CORNER()
!    write(*,*) 'fluid 3308:', surface_fluid%surface_points(:,3308)
        CALL UPDATE_RELATEDFACE(1,0,.TRUE.)
!    write(*,*) 'fluid 3308:', surface_fluid%surface_points(:,3308)
        CALL UPDATE_RELATEDFACE(1,2,.TRUE.)
        CALL UPDATE_IMPACT_ZONE(0,0)
        CALL UPDATE_IMPACT_ZONE(0,2)
        CALL UPDATE_IMPACT_ZONE(1,1)
!     write(*,*) 'fluid 3308:', surface_fluid%surface_points(:,3308)       
    END SUBROUTINE FLUID_MOVE
    
    SUBROUTINE STRUCT_MOVE()
        IMPLICIT NONE
        INTEGER :: I
        REAL(8) :: ZEROVEC(0)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
            SURFACE_FLUID%POINT_VELOCITY(:,I) = 0.
        END DO
        !$OMP END PARALLEL DO
        
        CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(1,:),SURFACE_CASE%POINT_VELOCITY(1,:),SURFACE_FLUID%POINT_VELOCITY(1,:),ZEROVEC)
        CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(2,:),SURFACE_CASE%POINT_VELOCITY(2,:),SURFACE_FLUID%POINT_VELOCITY(2,:),ZEROVEC)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
            SURFACE_PROPEL%SURFACE_POINTS(:,I) = SURFACE_PROPEL%SURFACE_POINTS(:,I) + SURFACE_PROPEL%POINT_VELOCITY(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CASE%SURFACE_POINTS_NUM
            SURFACE_CASE%SURFACE_POINTS(:,I) = SURFACE_CASE%SURFACE_POINTS(:,I) + SURFACE_CASE%POINT_VELOCITY(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
            SURFACE_FLUID%SURFACE_POINTS(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,I) + SURFACE_FLUID%POINT_VELOCITY(:,I)
        END DO
        !$OMP END PARALLEL DO
        
    END SUBROUTINE STRUCT_MOVE
   
    SUBROUTINE PRESSURE_TRANSFER()
	IMPLICIT NONE
        INTEGER :: I,J,I1,I2,I3
        
	REAL(8), ALLOCATABLE :: FLUID_POINT_PRESSURE(:)
	REAL(8), ALLOCATABLE :: TYP1_POINT(:,:)
	INTEGER, ALLOCATABLE :: TYP1_FACE(:,:)
	INTEGER, ALLOCATABLE :: TYP1_CONNECTION_NUM(:)
	INTEGER, ALLOCATABLE :: TYP1_CONNECTION(:,:)
	REAL(8), ALLOCATABLE :: TYP1_NORMAL(:,:)
	REAL(8), ALLOCATABLE :: TYP1_FACE_AREA(:)	
	REAL(8), ALLOCATABLE :: TYP2_POINT(:,:)
	INTEGER, ALLOCATABLE :: TYP2_FACE(:,:)
	REAL(8), ALLOCATABLE :: NORMAL(:,:)
	REAL(8), ALLOCATABLE :: AREA(:)
	REAL(8), ALLOCATABLE :: POINT_FORCE(:,:)
	REAL(8), ALLOCATABLE :: CR_SOURCE(:)
	REAL(8), ALLOCATABLE :: CR_TARGET(:)
	REAL(8) :: FLUID_TOTAL_PRESSURE, STRUCT_TOTAL_PRESSURE
	REAL(8) :: V1(3), V2(3), V3(3), V(3), POINT_I1(3), POINT_I2(3),POINT_I3(3), TEMP_FORCE(3)
	INTEGER :: TYP1_POINT_NUM, TYP2_POINT_NUM, TYP1_FACE_NUM, TYP2_FACE_NUM, TEMP_FACE_INDEX
	CHARACTER(500) :: STR

        SURFACE_FLUID%POINT_FORCE(:,:) = 0.
        SURFACE_PROPEL%POINT_FORCE(:,:) = 0.
        SURFACE_CASE%POINT_FORCE(:,:) = 0.
        
        ALLOCATE(FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_POINTS_NUM))
        FLUID_POINT_PRESSURE(:) = 0.
        DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
            FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(1,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(1,I)) + SURFACE_FLUID%FACE_PRESSURE(I)/3.
            FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(2,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(2,I)) + SURFACE_FLUID%FACE_PRESSURE(I)/3.
            FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(3,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(3,I)) + SURFACE_FLUID%FACE_PRESSURE(I)/3.
        END DO

        !CALL UPDATE_INTERFACE_CLUSTER(0)
        !CALL UPDATE_INTERFACE_CLUSTER(1)

        TYP1_POINT_NUM = INTERFACE_FLUID_POINTS_NUM + INTERFACE_FLUID_FACES_NUM
        ALLOCATE(TYP1_POINT(3,TYP1_POINT_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_FLUID_POINTS_NUM
                TYP1_POINT(:,I) = INTERFACE_FLUID_POINTS(:,I)
        END DO
        !$OMP END PARALLEL DO

	ALLOCATE(CR_SOURCE(TYP1_POINT_NUM))
        DO I=1,TYP1_POINT_NUM
            IF(I<=INTERFACE_FLUID_POINTS_NUM) THEN
                CR_SOURCE(I) = FLUID_POINT_PRESSURE(INTERFACE_FLUID_POINTS_LOC(1,I))
            ELSE
		TEMP_FACE_INDEX = INTERFACE_FLUID_FACES_LOC(1,I-INTERFACE_FLUID_POINTS_NUM)
                CR_SOURCE(I) = SURFACE_FLUID%FACE_PRESSURE(TEMP_FACE_INDEX)
            END IF
	    
        END DO

	TYP1_FACE_NUM = 3*INTERFACE_FLUID_FACES_NUM
        ALLOCATE(TYP1_FACE(3,TYP1_FACE_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_FLUID_FACES_NUM
		I1 = INTERFACE_FLUID_FACES(1,I)
		I2 = INTERFACE_FLUID_FACES(2,I)
		I3 = INTERFACE_FLUID_FACES(3,I)

		TYP1_POINT(:,I+INTERFACE_FLUID_POINTS_NUM) = (INTERFACE_FLUID_POINTS(:,I1) + INTERFACE_FLUID_POINTS(:,I2) + INTERFACE_FLUID_POINTS(:,I3))/3.0

                TYP1_FACE(1,3*I-2) = I1
                TYP1_FACE(2,3*I-2) = I2
                TYP1_FACE(3,3*I-2) = INTERFACE_FLUID_POINTS_NUM + I

                TYP1_FACE(1,3*I-1) = I2
                TYP1_FACE(2,3*I-1) = I3
                TYP1_FACE(3,3*I-1) = INTERFACE_FLUID_POINTS_NUM + I 

                TYP1_FACE(1,3*I-0) = I3
                TYP1_FACE(2,3*I-0) = I1
                TYP1_FACE(3,3*I-0) = INTERFACE_FLUID_POINTS_NUM + I 
        END DO
        !$OMP END PARALLEL DO

	ALLOCATE(TYP1_CONNECTION_NUM(TYP1_POINT_NUM))
	ALLOCATE(TYP1_CONNECTION(30,TYP1_POINT_NUM))

	TYP1_CONNECTION_NUM = 0
	TYP1_CONNECTION = 0

        DO I=1,TYP1_FACE_NUM
            DO J=1,3
                TYP1_CONNECTION_NUM(TYP1_FACE(J,I)) = TYP1_CONNECTION_NUM(TYP1_FACE(J,I)) + 1
                TYP1_CONNECTION(TYP1_CONNECTION_NUM(TYP1_FACE(J,I)),TYP1_FACE(J,I)) = I
            END DO
        END DO

	ALLOCATE(TYP1_NORMAL(3,TYP1_FACE_NUM))
	ALLOCATE(TYP1_FACE_AREA(TYP1_FACE_NUM))	

        DO I=1,TYP1_FACE_NUM
            V1 = TYP1_POINT(:,TYP1_FACE(1,I))
            V2 = TYP1_POINT(:,TYP1_FACE(2,I))
            V3 = TYP1_POINT(:,TYP1_FACE(3,I))
	    CALL VEC_CURL2(V1,V2,V1,V3,V)
	    TYP1_NORMAL(:,I) = V
	    TYP1_FACE_AREA(I) = SQRT(DOT_PRODUCT(V,V))/2.
        END DO

        TYP2_POINT_NUM = INTERFACE_STRUCT_POINTS_NUM + INTERFACE_STRUCT_FACES_NUM
        ALLOCATE(TYP2_POINT(3,TYP2_POINT_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP2_POINT_NUM
            IF(I<=INTERFACE_STRUCT_POINTS_NUM) THEN
                TYP2_POINT(:,I) = INTERFACE_STRUCT_POINTS(:,I)
            ELSE
		
            END IF
        END DO
        !$OMP END PARALLEL DO

	TYP2_FACE_NUM = 3*INTERFACE_STRUCT_FACES_NUM
        ALLOCATE(TYP2_FACE(3,TYP2_FACE_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_STRUCT_FACES_NUM
		I1 = INTERFACE_STRUCT_FACES(1,I)
		I2 = INTERFACE_STRUCT_FACES(2,I)
		I3 = INTERFACE_STRUCT_FACES(3,I)

                TYP2_POINT(:,I+INTERFACE_STRUCT_POINTS_NUM) = (INTERFACE_STRUCT_POINTS(:,I1) + INTERFACE_STRUCT_POINTS(:,I2) + INTERFACE_STRUCT_POINTS(:,I3))/3.0

	        TYP2_FACE(1,3*I-2) = I1
	        TYP2_FACE(2,3*I-2) = I2
	        TYP2_FACE(3,3*I-2) = INTERFACE_STRUCT_POINTS_NUM + I

	        TYP2_FACE(1,3*I-1) = I2
	        TYP2_FACE(2,3*I-1) = I3
	        TYP2_FACE(3,3*I-1) = INTERFACE_STRUCT_POINTS_NUM + I 

	        TYP2_FACE(1,3*I-0) = I3
	        TYP2_FACE(2,3*I-0) = I1
	        TYP2_FACE(3,3*I-0) = INTERFACE_STRUCT_POINTS_NUM + I 		
        END DO
        !$OMP END PARALLEL DO

	ALLOCATE(CR_TARGET(TYP2_POINT_NUM))
	CR_TARGET = 0.
	!CALL DATA_TRANSFER(3dCR)

        ALLOCATE(NORMAL(3,INTERFACE_STRUCT_FACES_NUM))
        ALLOCATE(AREA(INTERFACE_STRUCT_FACES_NUM))
        
        DO I=1,INTERFACE_STRUCT_FACES_NUM
            IF(INTERFACE_STRUCT_FACES_LOC(2,I)==1) THEN
		I1 = INTERFACE_STRUCT_POINTS_LOC(1,INTERFACE_STRUCT_FACES(1,I))
		I2 = INTERFACE_STRUCT_POINTS_LOC(1,INTERFACE_STRUCT_FACES(2,I))
		I3 = INTERFACE_STRUCT_POINTS_LOC(1,INTERFACE_STRUCT_FACES(3,I))
                POINT_I1 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(1,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I1)
                POINT_I2 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(2,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I2)
                POINT_I3 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(3,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I3)

            ELSE IF (INTERFACE_STRUCT_FACES_LOC(2,I)==2) THEN
		I1 = INTERFACE_STRUCT_POINTS_LOC(1,INTERFACE_STRUCT_FACES(1,I))
		I2 = INTERFACE_STRUCT_POINTS_LOC(1,INTERFACE_STRUCT_FACES(2,I))
		I3 = INTERFACE_STRUCT_POINTS_LOC(1,INTERFACE_STRUCT_FACES(3,I))
                POINT_I1 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(1,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I1)
                POINT_I2 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(2,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I2)
                POINT_I3 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(3,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I3)
	    ELSE
		I1 = INTERFACE_STRUCT_POINTS_LOC(1,INTERFACE_STRUCT_FACES(1,I))
		IF(INTERFACE_STRUCT_POINTS_LOC(2,INTERFACE_STRUCT_FACES(1,I))==1) THEN
		    POINT_I1 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(1,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I1)
		ELSE
		    POINT_I1 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(1,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I1)
		END IF

		I2 = INTERFACE_STRUCT_POINTS_LOC(1,INTERFACE_STRUCT_FACES(2,I))
		IF(INTERFACE_STRUCT_POINTS_LOC(2,INTERFACE_STRUCT_FACES(2,I))==1) THEN
		    POINT_I2 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(2,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I2)
		ELSE
		    POINT_I2 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(2,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I2)
		END IF

		I3 = INTERFACE_STRUCT_POINTS_LOC(1,INTERFACE_STRUCT_FACES(3,I))
		IF(INTERFACE_STRUCT_POINTS_LOC(2,INTERFACE_STRUCT_FACES(3,I))==1) THEN
		    POINT_I3 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(3,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I3)
		ELSE
		    POINT_I3 = INTERFACE_STRUCT_POINTS(:,INTERFACE_STRUCT_FACES(3,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I3)
		END IF
            END IF
            
	    CALL VEC_CURL2(POINT_I1,POINT_I2,POINT_I1,POINT_I3,NORMAL(:,I))
	    AREA(I) = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))/2.
            NORMAL(:,I) = NORMAL(:,I)/(2.*AREA(I)) 
        END DO


        ALLOCATE(POINT_FORCE(3,INTERFACE_STRUCT_POINTS_NUM))
        POINT_FORCE(:,:) = 0.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	CR_TARGET = 1.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        DO I=1,INTERFACE_STRUCT_FACES_NUM
            TEMP_FORCE = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + I) * AREA(I)/3. * NORMAL(:,I)
	    IF(INTERFACE_STRUCT_FACES_LOC(2,I) == 1) THEN
		SURFACE_PROPEL%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + I)
	    ELSE IF(INTERFACE_STRUCT_FACES_LOC(2,I) == 2) THEN
		SURFACE_CASE%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + I)
	    END IF

	    DO J = 1, 3
		POINT_FORCE(:,INTERFACE_STRUCT_FACES(J,I)) = POINT_FORCE(:,INTERFACE_STRUCT_FACES(J,I)) + TEMP_FORCE
	    END DO
        END DO

        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_STRUCT_POINTS_NUM
            IF(INTERFACE_STRUCT_POINTS_LOC(2,I)==1) THEN
                SURFACE_PROPEL%POINT_FORCE(:,INTERFACE_STRUCT_POINTS_LOC(1,I)) = POINT_FORCE(:,I)
            ELSE
                SURFACE_CASE%POINT_FORCE(:,INTERFACE_STRUCT_POINTS_LOC(1,I)) = POINT_FORCE(:,I)
            END IF
        END DO
        !$OMP END PARALLEL DO

IF(.FALSE.) THEN

	FLUID_TOTAL_PRESSURE = 1.
	STRUCT_TOTAL_PRESSURE = 0.
        TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,1) = FLUID_TOTAL_PRESSURE
        TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,2) = STRUCT_TOTAL_PRESSURE

	IF(FLUID_TOTAL_PRESSURE .NE. 0) THEN
           TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,3) = (STRUCT_TOTAL_PRESSURE-FLUID_TOTAL_PRESSURE)/(FLUID_TOTAL_PRESSURE) 
	END IF
        STR = './output/surface/totalpressure2d.txt'
        
        OPEN(UNIT=21, FILE = STR, ACTION = "WRITE", STATUS = "REPLACE")
        
        DO I = 1, SURFACE_PRESSURE_ITER
            WRITE(21,'(F,F,F)') TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,1), TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,2), TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,3)
        END DO
    
        CLOSE(21)
END IF
	DEALLOCATE(FLUID_POINT_PRESSURE)
	DEALLOCATE(TYP1_POINT)
	DEALLOCATE(TYP1_FACE)
	DEALLOCATE(TYP1_CONNECTION_NUM)
	DEALLOCATE(TYP1_CONNECTION)
	DEALLOCATE(TYP1_NORMAL)
	DEALLOCATE(TYP1_FACE_AREA)	
	DEALLOCATE(TYP2_POINT)
	DEALLOCATE(TYP2_FACE)
	DEALLOCATE(NORMAL)
	DEALLOCATE(AREA)
	DEALLOCATE(POINT_FORCE)
	DEALLOCATE(CR_SOURCE)
	DEALLOCATE(CR_TARGET)
    END SUBROUTINE PRESSURE_TRANSFER
    
    SUBROUTINE NEIGHBOR_RIDGE_PROJECTION(TYP1,I,TYP2,PROJ_TYP)
	IMPLICIT NONE
        INTEGER :: TYP1, TYP2, PROJ_TYP
        INTEGER :: I, J, L, M, I0, J1, J2, J3, J4, J5, J6, J7, FACE_INDEX, IDX
        REAL(8) :: DIST, TEMPDIST, DIST1, DIST2
	INTEGER, ALLOCATABLE :: RIDGE_EDGE(:,:)
	INTEGER :: RIDGE_EDGE_NUM, NUM
	REAL(8) :: A1(3), A2(3), T(3), R
	LOGICAL :: FLAG
        REAL(8) :: POINTDIST, INNER, INNER2

        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT1, SURFACE_CURRENT2
        
        IF (TYP1==0) THEN
            SURFACE_CURRENT1 => SURFACE_FLUID
        END IF
        IF (TYP1==1) THEN
            SURFACE_CURRENT1 => SURFACE_PROPEL
        END IF
        IF (TYP1==2) THEN
            SURFACE_CURRENT1 => SURFACE_CASE
        END IF        
        
        IF (TYP2==0) THEN
            SURFACE_CURRENT2 => SURFACE_FLUID
        END IF
        IF (TYP2==1) THEN
            SURFACE_CURRENT2 => SURFACE_PROPEL
        END IF
        IF (TYP2==2) THEN
            SURFACE_CURRENT2 => SURFACE_CASE
        END IF        
        
		DIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		DIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
        
		J = SURFACE_CURRENT1%POINT_RELATEDFACE(TYP2+1,I)       
	    ALLOCATE(RIDGE_EDGE(2,100))        
		RIDGE_EDGE_NUM = 0
		DO L= 1,3
		    I0 = SURFACE_CURRENT2%SURFACE_FACES(L,J)
		    NUM = SURFACE_CURRENT2%POINT_FACE_CONNECTION_NUM(I0)
			    DO M= 1,NUM
			    	FACE_INDEX = SURFACE_CURRENT2%POINT_FACE_CONNECTION(M,I0)
				    J1 = SURFACE_CURRENT2%SURFACE_FACES(1,FACE_INDEX)
				    J2 = SURFACE_CURRENT2%SURFACE_FACES(2,FACE_INDEX)
				    J3 = SURFACE_CURRENT2%SURFACE_FACES(3,FACE_INDEX)
				IF(SURFACE_CURRENT2%POINT_TYPE(J1)==PROJ_TYP .AND. SURFACE_CURRENT2%POINT_TYPE(J2)==PROJ_TYP) THEN
				    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
				    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J1
				    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J2
				END IF
				IF(SURFACE_CURRENT2%POINT_TYPE(J2)==PROJ_TYP .AND. SURFACE_CURRENT2%POINT_TYPE(J3)==PROJ_TYP) THEN
				    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
				    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J2
				    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J3
				END IF
				IF(SURFACE_CURRENT2%POINT_TYPE(J3)==PROJ_TYP .AND. SURFACE_CURRENT2%POINT_TYPE(J1)==PROJ_TYP) THEN
				    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
				    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J3
				    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J1
				END IF
			    END DO
		    END DO

	    IF(RIDGE_EDGE_NUM==0) THEN
		WRITE(*,*) 'ERROR : RIDGE_EDGE_NUM == 0, WHEN ATTEMPT TO PROJECTION ONTO RIDGES'
            ELSE
                
			DIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))            
            		TEMPDIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
            
			DO L=1,RIDGE_EDGE_NUM
			    J4 = RIDGE_EDGE(1,L)
			    J5 = RIDGE_EDGE(2,L)
			    CALL UNSIGNED_DISTANCE_EDGE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,J4),SURFACE_CURRENT2%SURFACE_POINTS(:,J5),TEMPDIST)
			    IF(TEMPDIST<DIST) THEN
				DIST = TEMPDIST
				IDX = L
			    END IF
		        END DO
			J6 = RIDGE_EDGE(1,IDX)
			J7 = RIDGE_EDGE(2,IDX)
        
			DIST1 = SQRT(DOT_PRODUCT(SURFACE_CURRENT1%SURFACE_POINTS(:,I)-SURFACE_CURRENT2%SURFACE_POINTS(:,J6),SURFACE_CURRENT1%SURFACE_POINTS(:,I)-SURFACE_CURRENT2%SURFACE_POINTS(:,J6)))
			DIST2 = SQRT(DOT_PRODUCT(SURFACE_CURRENT1%SURFACE_POINTS(:,I)-SURFACE_CURRENT2%SURFACE_POINTS(:,J7),SURFACE_CURRENT1%SURFACE_POINTS(:,I)-SURFACE_CURRENT2%SURFACE_POINTS(:,J7)))
            
			IF(DIST1 < DIST2) THEN
			    A1 = SURFACE_CURRENT2%SURFACE_POINTS(:,J6)
			    A2 = SURFACE_CURRENT2%SURFACE_POINTS(:,J7)
			    
			    POINTDIST = DIST1
			    FLAG = .FALSE.
			ELSE
			    A1 = SURFACE_CURRENT2%SURFACE_POINTS(:,J7)
			    A2 = SURFACE_CURRENT2%SURFACE_POINTS(:,J6)
			    
			    POINTDIST = DIST2
			    FLAG = .TRUE.
			END IF
        
      			INNER = DOT_PRODUCT(A1-SURFACE_CURRENT1%SURFACE_POINTS(:,I),A2-A1)
			T = A2-A1
			R = SQRT(DOT_PRODUCT(T,T))
			T = T/R
			INNER2 = DOT_PRODUCT(SURFACE_CURRENT1%SURFACE_POINTS(:,I)-A1,T)
        
			SURFACE_CURRENT1%POINT_VELOCITY(:,I) = A1 + INNER2 * T- SURFACE_CURRENT1%SURFACE_POINTS(:,I)		
	    END IF
		    DEALLOCATE(RIDGE_EDGE) 			
        
    END SUBROUTINE NEIGHBOR_RIDGE_PROJECTION
    
    SUBROUTINE WAVEFRONT_DISPLACEMENT(TYP, TIMESTEP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        REAL(8) :: TIMESTEP
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        
        REAL(8), ALLOCATABLE :: FACE_AREA(:)
        REAL(8), ALLOCATABLE :: FACE_CENTER(:,:)
        
        INTEGER :: I,J,K,L, IDX, POINT_IDX
        INTEGER :: I1,I2,I3, J1,J2,J3,J4,J5,J6, N1,N2,N3,N4,N5,N6, TEMP_I, TEMP1, TEMP2
        REAL(8) :: V(3), V1(3),V2(3),V3(3),R, TEMPVEC(3), TEMP_NORMAL(3), L1, L2
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        INTEGER :: CON_NUM, GOOD_FACE, RELATED_FACE, NEW_RELATED_FACE
        
        INTEGER :: LOCAL_SHAPE
        
        REAL(8), ALLOCATABLE :: N(:,:), A(:), W(:)
        REAL(8) :: W_SUM
        REAL(8) :: B(3)
        
        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        
        INTEGER :: JMIN, TEMP, TEMP_INDEX
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3), TEST_POINT1(3), TEST_POINT2(3)
        
        REAL(8), ALLOCATABLE :: TEMPPOINT(:,:)
        INTEGER, ALLOCATABLE :: TEMPFACE(:,:)
        
        REAL(8), ALLOCATABLE :: LENGTH(:)
        REAL(8), ALLOCATABLE :: MU(:), LL(:), COSTHETA(:)
        REAL(8) :: MU_SUM
        LOGICAL :: EXPANDING, FLAG1, FLAG2, FLAG3, B0, B1, B2, B3
        
        REAL(8) :: D(3),AXIS(3),DIR(3)
        
        REAL(8) :: THETA_A, PHI_C, PHI_R, CHI_C, CHI_R
	REAL(8) :: POINT_DIST, MINDIST, MINDIST1, MINDIST2, DIST1, DIST2, DIST3, DISTANCE
	REAL(8) :: ORIGINAL_MOVE_POINT(3), COPY_POINT(3), PROJ_POINT(3)
    
       INTEGER :: RIDGE_NUM, FACE_IDX, VERTEX, NUM, NEIGHBOR_INDEX, POINT_IDX1, POINT_IDX2, POINT_IDX3, RIDGE(2)
       REAL(8) :: NEIGHBOR_RIDGE_POINT(3,2), TEMP_POINT(3), INNER1, INNER2, CRI
	REAL(8) :: RELATED_NORMAL(3), TEMP_NEIGHBOR_NORMAL(3), NEIGHBOR_NORMAL(3), DIST, DIR1(3), DIR2(3), W1(3), W2(3), TEMP_DIST
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        
        ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))
        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
            
            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            
            ! Should modify for square case
            
            CALL VEC_CURL1(V1,V2, NORMAL(:,I))
            
            R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))

if(R < minerror) then
write(*,*) typ, i1, i2, i3
write(*,*) surface_current%surface_points(:,i1)
write(*,*) surface_current%surface_points(:,i2)
write(*,*) surface_current%surface_points(:,i3)
write(*,*) surface_current%point_type(i1), surface_current%point_type(i2), surface_current%point_type(i3)
write(*,*) surface_current%point_relatedface(3,i2), surface_current%point_relatedface(3,i3) 
end if                      
            FACE_AREA(I) = R/2.
            

            NORMAL(:,I) = NORMAL(:,I) / R
            
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM

            CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(A(CON_NUM))
            ALLOCATE(W(CON_NUM))
            
            W_SUM = 0.
            THETA_A = 0.
            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                I1 = SURFACE_CURRENT%SURFACE_FACES(1,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I2 = SURFACE_CURRENT%SURFACE_FACES(2,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I3 = SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF
                
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) / W_SUM
                A(J) = TIMESTEP * SURFACE_CURRENT%FACE_B_RATE(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
                
                B(K) = 0.
                DO J = 1,CON_NUM
                    B(K) = B(K) + W(J)*N(J,K)*A(J)
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,2
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            
            THETA_A = THETA_A - 2.*PI
        
            PHI_R = 14. * PI/180.
            PHI_C = 45. * PI/180.
            
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF
            
            DISPLACEMENT(:,I) = 0.

	    DO J = 1,LOCAL_SHAPE
                DISPLACEMENT(:,I) = DISPLACEMENT(:,I) + DOT_PRODUCT(E_VECTOR(:,J),B(:))/E_VALUE(J) * E_VECTOR(:,J)
	    END DO
            
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))==0) THEN
                DEALLOCATE(N)
                DEALLOCATE(A)
                DEALLOCATE(W)
                CYCLE
	    END IF

	    !IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))<1E-5 .AND. E_VALUE(2)/E_VALUE(1) > CHI_R/2. .AND. LOCAL_SHAPE == 1) THEN
	!	DISPLACEMENT(:,I) = DISPLACEMENT(:,I) + DOT_PRODUCT(E_VECTOR(:,2),B(:))/E_VALUE(2) * E_VECTOR(:,2)
	    !END IF

	    AXIS(1) = 1.
	    AXIS(2) = 0.
	    AXIS(3) = 0.
	    FLAG1 = .FALSE.
	    FLAG2 = .FALSE.
	    FLAG3 = .FALSE.
	    TEMP1 = 0
	    TEMP2 = 0
	    TEMP = 0

IF(SURFACE_CURRENT%INITIAL_POINT_TYPE(I)==2) THEN
		ALLOCATE(TEMPFACE(2,10))
		TEMPFACE = 0
	        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
		    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==-1) THEN
			FLAG1 = .TRUE.
			TEMP1 = TEMP1 +1
			TEMPFACE(1,TEMP1) = K
		    END IF
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)== 1) THEN
			FLAG2 = .TRUE.
			GOOD_FACE = K
		    END IF
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)== 2) THEN
			FLAG3 = .TRUE.
			TEMP2 = TEMP2 +1
			TEMPFACE(2,TEMP2) = K
		    END IF		
	        END DO

		IF(FLAG1 .AND. FLAG2) THEN
		    TEMP_NORMAL = 0.
		    DO J = 1, TEMP1
		        V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,TEMPFACE(1,J))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(1,J))) 
		        V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,TEMPFACE(1,J))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(1,J)))
		        CALL VEC_CURL1(V1,V2,TEMPVEC)
			TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
			TEMP_NORMAL = TEMP_NORMAL + TEMPVEC/REAL(TEMP1)		
		    END DO
		    TEMP_NORMAL = TEMP_NORMAL/SQRT(DOT_PRODUCT(TEMP_NORMAL,TEMP_NORMAL))

		    IF (DOT_PRODUCT(DISPLACEMENT(:,I),TEMP_NORMAL)>0) THEN
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),TEMP_NORMAL)*TEMP_NORMAL
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))
		    END IF
		END IF

		IF(FLAG1 .AND. FLAG3) THEN
		    TEMP_NORMAL = 0.
		    DO J = 1, TEMP2
		        V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,TEMPFACE(2,J))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(2,J))) 
		        V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,TEMPFACE(2,J))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(2,J)))
		        CALL VEC_CURL1(V1,V2,TEMPVEC)
			TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
			TEMP_NORMAL = TEMP_NORMAL + TEMPVEC/REAL(TEMP2)		
		    END DO
		    TEMP_NORMAL = TEMP_NORMAL/SQRT(DOT_PRODUCT(TEMP_NORMAL,TEMP_NORMAL))

		    IF (DOT_PRODUCT(DISPLACEMENT(:,I),TEMP_NORMAL)>0) THEN
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),TEMP_NORMAL)*TEMP_NORMAL
			DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))
		    END IF
		END IF

		DEALLOCATE(TEMPFACE)

ELSE IF(SURFACE_CURRENT%INITIAL_POINT_TYPE(I)==3) THEN
	        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
		    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==-1) THEN
			FLAG1 = .TRUE.
		    END IF
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)== 1) THEN
			FLAG2 = .TRUE.
			GOOD_FACE = K
		    END IF
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)== 2) THEN
			FLAG3 = .TRUE.
		    END IF		
	        END DO

		IF(FLAG1 .AND. FLAG2 .AND. FLAG3) THEN
		    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,GOOD_FACE)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,GOOD_FACE)) 
		    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,GOOD_FACE)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,GOOD_FACE))
		    CALL VEC_CURL1(V1,V2,TEMPVEC)
		    IF (DOT_PRODUCT(TEMPVEC,AXIS)>0) THEN
			DISPLACEMENT(:,I) = AXIS
		    ELSE
			DISPLACEMENT(:,I) = -AXIS
		    END IF
		ELSE
		    !WRITE(*,*) 'UNEXPECTED CORNER!'
		END IF
ELSE IF(SURFACE_CURRENT%INITIAL_POINT_TYPE(I)==4) THEN 

            RIDGE_NUM = 0
            NEIGHBOR_RIDGE_POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
            NEIGHBOR_RIDGE_POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
        
            DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                IF(SURFACE_CURRENT%FACE_ONINTERFACE(FACE_IDX)==1-TYP) THEN
                    DO K = 1, 3
		        IF((SURFACE_CURRENT%POINT_TYPE(SURFACE_CURRENT%SURFACE_FACES(K,FACE_IDX)) .GE. 4).AND. SURFACE_CURRENT%SURFACE_FACES(K,FACE_IDX) .NE. I) THEN
                            TEMP_POINT = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K,FACE_IDX))
                            IF(DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1))>MINERROR .AND. DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2))>MINERROR) THEN
                                RIDGE_NUM = RIDGE_NUM + 1
                                NEIGHBOR_RIDGE_POINT(:,RIDGE_NUM) = TEMP_POINT
                                EXIT
                            END IF
                            EXIT
			END IF
                    END DO
		END IF  
                IF(RIDGE_NUM == 2) EXIT
            END DO
     
            IF(RIDGE_NUM < 2) THEN
                WRITE(*,*) 'END OF THE RIDGE FOUND'
                WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,1)
                WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,2)
                WRITE(*,*) 'INDICES : ', I, J
            END IF
        
            V1 = NEIGHBOR_RIDGE_POINT(:,1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            L1 = SQRT(DOT_PRODUCT(V1,V1))
            V2 = -(NEIGHBOR_RIDGE_POINT(:,2) - SURFACE_CURRENT%SURFACE_POINTS(:,I))
            L2 = SQRT(DOT_PRODUCT(V2,V2))        
        
            V = L1*V1 + L2*V2
            V = V/SQRT(DOT_PRODUCT(V,V))
        
            RELATED_FACE = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)
	    V1 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE)) 
	    V2 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE))
	    CALL VEC_CURL1(V1,V2,RELATED_NORMAL)
	    RELATED_NORMAL = RELATED_NORMAL/SQRT(DOT_PRODUCT(RELATED_NORMAL,RELATED_NORMAL))

	    
            DIST = 100
	    B0 = .FALSE.

	    DO J = 1, 3
		VERTEX = SURFACE_CASE%SURFACE_FACES(J,RELATED_FACE)
		NUM = SURFACE_CASE%POINT_FACE_CONNECTION_NUM(VERTEX)
		DO L = 1, NUM
		    K = SURFACE_CASE%POINT_FACE_CONNECTION(L,VERTEX)
		    CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,I), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)), TEMP_DIST)	

		    W1 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K))  
		    W2 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K)) 
	    	    CALL VEC_CURL1(W1,W2,TEMP_NEIGHBOR_NORMAL)
	    	    TEMP_NEIGHBOR_NORMAL = TEMP_NEIGHBOR_NORMAL/SQRT(DOT_PRODUCT(TEMP_NEIGHBOR_NORMAL,TEMP_NEIGHBOR_NORMAL))
		    CRI = SQRT(MAX(0.,1.-DOT_PRODUCT(RELATED_NORMAL,TEMP_NEIGHBOR_NORMAL)*DOT_PRODUCT(RELATED_NORMAL,TEMP_NEIGHBOR_NORMAL)))

		    IF(K/=RELATED_FACE .AND. TEMP_DIST<DIST .AND. CRI>0.5 .AND. SURFACE_CASE%FACE_ONINTERFACE(K) .NE. -1 ) THEN
			B0 = .TRUE.
			DIST = TEMP_DIST
			NEIGHBOR_NORMAL = TEMP_NEIGHBOR_NORMAL	
			NEIGHBOR_INDEX = K

		    END IF 

		END DO
	    END DO

            CALL VEC_CURL1(RELATED_NORMAL,V,DIR1)

	    IF(B0) THEN
	        CALL VEC_CURL1(NEIGHBOR_NORMAL,V,DIR2)
                IF(DOT_PRODUCT(DIR2,DIR2)<MINERROR) THEN
                    WRITE(*,*) 'PARALLEL PLANES APPEAR WHEN FLUID PT TYP==4, DIR2'
                    WRITE(*,*) 'INDEX :', I
		    WRITE(*,*) 'NEIGHBOR_INDEX :', NEIGHBOR_INDEX
		END IF
            END IF
            IF(DOT_PRODUCT(DIR1,DIR1)<MINERROR) THEN
                WRITE(*,*) 'PARALLEL PLANES APPEAR WHEN FLUID PT TYP==4, DIR1'
                WRITE(*,*) 'INDEX :', I
		WRITE(*,*) 'NEIGHBOR_INDEX :', NEIGHBOR_INDEX
            ELSE
                DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))
		IF(DOT_PRODUCT(DISPLACEMENT(:,I),DIR1)<0) THEN
		    DIR = -DIR1
		ELSE
		    DIR = DIR1
		END IF
		IF(B0) THEN
                    DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
		    IF(DOT_PRODUCT(DISPLACEMENT(:,I),DIR2)<0) THEN
		         DIR2 = -DIR2
		    END IF

		    NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
		    DO L = 1, NUM
		        K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
		        IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
		   	    W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
		   	    W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
	    	   	    CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
			    INNER1 = DOT_PRODUCT(TEMP_NORMAL,DIR)
			    INNER2 = DOT_PRODUCT(TEMP_NORMAL,DIR2)
			    IF(INNER1>0. .AND. INNER1>=INNER2) THEN
				DIR = DIR
				EXIT
			    ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
				DIR = DIR2
				EXIT
			    ELSE
				WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==4,5'
				WRITE(*,*) DIR
				WRITE(*,*) DIR2
				WRITE(*,*) TEMP_NORMAL
				WRITE(*,*) I, K
			    END IF
			END IF
		    END DO
		END IF

		DISPLACEMENT(:,I) = DIR
  
            END IF

ELSE IF(SURFACE_CURRENT%INITIAL_POINT_TYPE(I)==5) THEN
        RELATED_FACE = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)
        B1 = .FALSE.
        
        DO L = 1, 3
            POINT_IDX = SURFACE_CASE%SURFACE_FACES(L,RELATED_FACE)
            IF(SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX)-SURFACE_CURRENT%SURFACE_POINTS(:,I),SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX)-SURFACE_CURRENT%SURFACE_POINTS(:,I)))<SURFACE_FLUID%MESH_SIZE/100.) THEN
                IDX = L
                B1 = .TRUE.
                EXIT
            END IF
        END DO

		J1 = SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE)
		J2 = SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE)
		J3 = SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)
        
        RIDGE_NUM = 0
        DO L = 1,3
            IF(SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(L,RELATED_FACE)>0) THEN
                RIDGE_NUM = RIDGE_NUM + 1
            END IF
        END DO
        
		N1 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(1,RELATED_FACE)
		N2 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(2,RELATED_FACE)
		N3 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(3,RELATED_FACE)
        
		IF(.NOT. B1 .AND. RIDGE_NUM == 1) THEN
            IF(N1 == 1) THEN
                POINT_IDX1 = J1
                POINT_IDX2 = J2
            ELSE IF(N2 == 1) THEN
                POINT_IDX1 = J2
                POINT_IDX2 = J3                
            ELSE
                POINT_IDX1 = J3
                POINT_IDX2 = J1                 
            END IF
            
		        DIR1 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                DIR2 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX2) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                
                DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))
                DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
            
                MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
                MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
                
                DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                    FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                    TEST_POINT1 = SURFACE_CURRENT%SURFACE_POINTS(:,I) + SURFACE_FLUID%MESH_SIZE*DIR1
                    TEST_POINT2 = SURFACE_CURRENT%SURFACE_POINTS(:,I) + SURFACE_FLUID%MESH_SIZE*DIR2
                    IF(SURFACE_CURRENT%FACE_ONINTERFACE(FACE_IDX)==2) THEN
                        V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
                        V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
                        V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
                        CALL UNSIGNED_DISTANCE_FACE_POINT(TEST_POINT1,V1,V2,V3,DIST1)
                        CALL UNSIGNED_DISTANCE_FACE_POINT(TEST_POINT2,V1,V2,V3,DIST2)
                        IF(DIST1<MINDIST1) THEN
                        MINDIST1 = DIST1
                        END IF
                        IF(DIST2<MINDIST2) THEN
                        MINDIST2 = DIST2
                        END IF  
                    END IF
                END DO
            
            IF(MINDIST1<MINDIST2) THEN
                DISPLACEMENT(:,I) = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))    
            ELSEIF(MINDIST2<MINDIST1) THEN
                DISPLACEMENT(:,I) = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))                  
            END IF
            
        ELSEIF(.NOT. B1 .AND. RIDGE_NUM == 2) THEN
            IF(N1 == 1 .AND. N2 == 1) THEN
                POINT_IDX1 = J1
                POINT_IDX2 = J2
                POINT_IDX3 = J3
            ELSE IF(N2 == 1 .AND. N3 == 1) THEN
                POINT_IDX1 = J2
                POINT_IDX2 = J3  
                POINT_IDX3 = J1
            ELSE
                POINT_IDX1 = J3
                POINT_IDX2 = J1  
                POINT_IDX3 = J2 
            END IF
            
		    DIR1 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX1) - SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2)
            DIR2 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX3) - SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2)
            
            DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))
            DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
            
            TEMPVEC = SURFACE_CURRENT%SURFACE_POINTS(:,I) - SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2)
            TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
            
            INNER1 = DOT_PRODUCT(TEMPVEC, DIR1)
            INNER2 = DOT_PRODUCT(TEMPVEC, DIR2)
            
            IF(INNER1>=INNER2) THEN
                DIR2 = -DIR1
            ELSE
                DIR1 = -DIR2
            END IF

            TEST_POINT1 = SURFACE_CURRENT%SURFACE_POINTS(:,I) + SURFACE_FLUID%MESH_SIZE*DIR1
            TEST_POINT2 = SURFACE_CURRENT%SURFACE_POINTS(:,I) + SURFACE_FLUID%MESH_SIZE*DIR2
            
            MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
            MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
                
            DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                IF(SURFACE_CURRENT%FACE_ONINTERFACE(FACE_IDX)==2) THEN
                    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
                    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
                    V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
                    CALL UNSIGNED_DISTANCE_FACE_POINT(TEST_POINT1,V1,V2,V3,DIST1)
                    CALL UNSIGNED_DISTANCE_FACE_POINT(TEST_POINT2,V1,V2,V3,DIST2)
                    IF(DIST1<MINDIST1) THEN
                    MINDIST1 = DIST1
                    END IF
                    IF(DIST2<MINDIST2) THEN
                    MINDIST2 = DIST2
                    END IF  
                END IF
            END DO
            
            IF(MINDIST1<MINDIST2) THEN
                DISPLACEMENT(:,I) = DIR2  
            ELSEIF(MINDIST2<MINDIST1) THEN
                DISPLACEMENT(:,I) = DIR1                
            END IF

        ELSEIF(B1) THEN
            
            POINT_IDX = SURFACE_CASE%SURFACE_FACES(IDX,RELATED_FACE)
            NUM = 0           
            DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(POINT_IDX)     
                K = SURFACE_CASE%POINT_FACE_CONNECTION(J,POINT_IDX)

                IF(SURFACE_CASE%FACE_ONINTERFACE(K) == -1)  THEN
                    DO L = 1,3
                        IF(SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(L,K)>0) THEN
                            NUM = NUM + 1
                            IF(L==1) THEN
                                I1 = SURFACE_CASE%SURFACE_FACES(1,K)
                                I2 = SURFACE_CASE%SURFACE_FACES(2,K)
                            ELSEIF(L==2)THEN
                                I1 = SURFACE_CASE%SURFACE_FACES(2,K)
                                I2 = SURFACE_CASE%SURFACE_FACES(3,K)
                            ELSE
                                I1 = SURFACE_CASE%SURFACE_FACES(3,K)
                                I2 = SURFACE_CASE%SURFACE_FACES(1,K)
                            END IF
                            
                            IF(I1==POINT_IDX)THEN
                                RIDGE(NUM) = I2
                            ELSE
                                RIDGE(NUM) = I1
                            END IF
                        END IF
                    END DO
                END IF
            END DO
            if(ridge(1) ==0 .or. ridge(2) ==0) then
                write(*,*) 'index:', i
            end if
		    DIR1 = SURFACE_CASE%SURFACE_POINTS(:,RIDGE(1)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            DIR2 = SURFACE_CASE%SURFACE_POINTS(:,RIDGE(2)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            
            DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))
            DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
            
            TEST_POINT1 = SURFACE_CURRENT%SURFACE_POINTS(:,I) + SURFACE_FLUID%MESH_SIZE*DIR1
            TEST_POINT2 = SURFACE_CURRENT%SURFACE_POINTS(:,I) + SURFACE_FLUID%MESH_SIZE*DIR2
            
            MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
            MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
                
            DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
                    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
                    V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
                    CALL UNSIGNED_DISTANCE_FACE_POINT(TEST_POINT1,V1,V2,V3,DIST1)
                    CALL UNSIGNED_DISTANCE_FACE_POINT(TEST_POINT2,V1,V2,V3,DIST2)
                    IF(DIST1<MINDIST1) THEN
                    MINDIST1 = DIST1
                    END IF
                    IF(DIST2<MINDIST2) THEN
                    MINDIST2 = DIST2
                    END IF  
            END DO   
            
            IF(MINDIST1<MINDIST2) THEN
                DISPLACEMENT(:,I) = DIR2  
            ELSEIF(MINDIST2<MINDIST1) THEN
                DISPLACEMENT(:,I) = DIR1                
            END IF
        ELSE
            WRITE(*,*) 'MANG'
           ! B2 = .FALSE.
           ! IF(B1) THEN
           !     DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(POINT_IDX)
           !         NEW_RELATED_FACE = SURFACE_CASE%POINT_FACE_CONNECTION(J,POINT_IDX)
           !         J4 = SURFACE_CASE%SURFACE_FACES(1,NEW_RELATED_FACE)
           !         J5 = SURFACE_CASE%SURFACE_FACES(2,NEW_RELATED_FACE)
			        !J6 = SURFACE_CASE%SURFACE_FACES(3,NEW_RELATED_FACE)
			        !N4 = SURFACE_CASE%POINT_TYPE(J4)
			        !N5 = SURFACE_CASE%POINT_TYPE(J5)
			        !N6 = SURFACE_CASE%POINT_TYPE(J6)
           !         
		         !   IF(N4 .GE. 2 .AND. N5 .GE. 2) THEN
		         !       DIR1 = SURFACE_CASE%SURFACE_POINTS(:,J4) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           !             DIR2 = SURFACE_CASE%SURFACE_POINTS(:,J5) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           ! 
           !             MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		         !       MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))    
           ! 
           !             DO K = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
           !                 FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(K,I)                            
           !                 V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
           !                 V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
           !                 V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
           !                                     
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J4),V1,V2,V3,DIST1)
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J5),V1,V2,V3,DIST2)                            
           !                 IF(DIST1<MINDIST1) THEN
           !                 MINDIST1 = DIST1
           !                 END IF
           !                 IF(DIST2<MINDIST2) THEN
           !                 MINDIST2 = DIST2
           !                 END IF            
           !             END DO
           ! 
           !             IF(MINDIST1<MINDIST2) THEN
           !                 DISPLACEMENT(:,I) = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))    
           !             ELSEIF(MINDIST2<MINDIST1) THEN
           !                 DISPLACEMENT(:,I) = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))                  
           !             END IF
           ! 
		         !   ELSEIF(N5 .GE. 2 .AND. N6 .GE. 2) THEN
		         !       DIR1 = SURFACE_CASE%SURFACE_POINTS(:,J5) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           !             DIR2 = SURFACE_CASE%SURFACE_POINTS(:,J6) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           ! 
           !             MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		         !       MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))    
           ! 
           !             DO K = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
           !                 FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(K,I)
           !                 V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
           !                 V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
           !                 V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
           !                                     
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J5),V1,V2,V3,DIST1)
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J6),V1,V2,V3,DIST2) 
           !                 IF(DIST1<MINDIST1) THEN
           !                 MINDIST1 = DIST1
           !                 END IF
           !                 IF(DIST2<MINDIST2) THEN
           !                 MINDIST2 = DIST2
           !                 END IF            
           !             END DO
           ! 
           !             IF(MINDIST1<MINDIST2) THEN
           !                 DISPLACEMENT(:,I) = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))    
           !             ELSEIF(MINDIST2<MINDIST1) THEN
           !                 DISPLACEMENT(:,I) = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))                  
           !             END IF
           !
		         !   ELSEIF(N6 .GE. 2 .AND. N4 .GE. 2) THEN
		         !       DIR1 = SURFACE_CASE%SURFACE_POINTS(:,J6) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           !             DIR2 = SURFACE_CASE%SURFACE_POINTS(:,J4) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
           ! 
           !             MINDIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		         !       MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))    
           ! 
           !             DO K = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
           !                 FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(K,I)
           !                 V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,FACE_IDX))
           !                 V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,FACE_IDX))
           !                 V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,FACE_IDX))
           !                                     
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J6),V1,V2,V3,DIST1)
           !                 CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,J4),V1,V2,V3,DIST2) 
           !                 IF(DIST1<MINDIST1) THEN
           !                 MINDIST1 = DIST1
           !                 END IF
           !                 IF(DIST2<MINDIST2) THEN
           !                 MINDIST2 = DIST2
           !                 END IF            
           !             END DO
           ! 
           !             IF(MINDIST1<MINDIST2) THEN
           !                 DISPLACEMENT(:,I) = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))    
           !             ELSEIF(MINDIST2<MINDIST1) THEN
           !                 DISPLACEMENT(:,I) = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))                  
           !             END IF
           !
           !         ELSE
           !             B2 = .TRUE.
			        !END IF 
           !         
           !     END DO    
           ! END IF    
           ! 
           ! IF(B2) THEN
           !     WRITE(*,*) 'FAIL TO CHANGE RELATED FACE'
           ! END IF
        END IF
            
		 !   MINDIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		 !   B3 = .FALSE.
		 !   DO L = 1, 3
			!TEMP = SURFACE_CASE%SURFACE_FACES(L,RELATED_FACE)
		 !       POINT_DIST = SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,TEMP),SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,TEMP)))
			!IF(POINT_DIST<MINDIST) THEN
			!   MINDIST = POINT_DIST
			!   IDX = TEMP
			!END IF
   !         END DO
   !
   !         B3 = .TRUE.
		 !   
		 !   IF(B3) THEN
			!ORIGINAL_MOVE_POINT = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I) 
			!MINDIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
			!DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(IDX) 
			!    TEMP_INDEX = SURFACE_CASE%POINT_FACE_CONNECTION(J,IDX)
			!    J1 = SURFACE_CASE%SURFACE_FACES(1,TEMP_INDEX)
			!    J2 = SURFACE_CASE%SURFACE_FACES(2,TEMP_INDEX)
			!    J3 = SURFACE_CASE%SURFACE_FACES(3,TEMP_INDEX)
			!    V1 = SURFACE_CASE%SURFACE_POINTS(:,J2)- SURFACE_CASE%SURFACE_POINTS(:,J1)
			!    V2 = SURFACE_CASE%SURFACE_POINTS(:,J3)- SURFACE_CASE%SURFACE_POINTS(:,J1)
			!    CALL VEC_CURL1(V1,V2,TEMP_NORMAL)
			!    TEMP_NORMAL = TEMP_NORMAL/SQRT(DOT_PRODUCT(TEMP_NORMAL,TEMP_NORMAL))
			!    PROJ_POINT = ORIGINAL_MOVE_POINT - DOT_PRODUCT(ORIGINAL_MOVE_POINT,TEMP_NORMAL)*TEMP_NORMAL
			!    CALL UNSIGNED_DISTANCE_FACE_POINT(PROJ_POINT,SURFACE_CASE%SURFACE_POINTS(:,J1),SURFACE_CASE%SURFACE_POINTS(:,J2),SURFACE_CASE%SURFACE_POINTS(:,J3),DISTANCE)
			!	IF(DISTANCE<MINDIST2) THEN
			!	    MINDIST2 = DISTANCE
			!	    SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I) = TEMP_INDEX
			!	END IF
			!END DO

            !END IF
	ELSE
		DO J = 1,LOCAL_SHAPE
                    DISPLACEMENT(:,I) = DISPLACEMENT(:,I) + DOT_PRODUCT(E_VECTOR(:,J),B(:))/E_VALUE(J) * E_VECTOR(:,J)
		END DO
	END IF

            DEALLOCATE(N)
            DEALLOCATE(A)
            DEALLOCATE(W)
            
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))>0) THEN
                SURFACE_CURRENT%POINT_FORCE(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))
            ELSE
                SURFACE_CURRENT%POINT_FORCE(:,I) = 0.
            END IF
        END DO
        
        !CALL NEAR_CASE_DISPLACEMENT(TYP, DISPLACEMENT)
        
        ALLOCATE(TEMPPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            TEMPPOINT(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        
        ALLOCATE(LENGTH(SURFACE_CURRENT%SURFACE_POINTS_NUM))
        LENGTH(:) = 0.
        
        ALLOCATE(FACE_CENTER(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
            
            ! Should modify for square case
            
            !FACE_CENTER(:,I) = (TEMPPOINT(:,I1) + TEMPPOINT(:,I2) + TEMPPOINT(:,I3))/3.
            FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3))/3.
            
        END DO
        
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))<MINERROR) THEN
                LENGTH(I) = 0.
            ELSE
                CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)

                ALLOCATE(A(CON_NUM))
                ALLOCATE(W(CON_NUM))
                ALLOCATE(MU(CON_NUM))
                ALLOCATE(LL(CON_NUM))
                ALLOCATE(COSTHETA(CON_NUM))
                
                MU_SUM = 0.
                
                DO J = 1,CON_NUM
                    W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                    A(J) = TIMESTEP * SURFACE_CURRENT%FACE_B_RATE(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                    COSTHETA(J) = DOT_PRODUCT(DISPLACEMENT(:,I), NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))) &
                    /SQRT( DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)) * DOT_PRODUCT(NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)),NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))) )
                    
                    
                    ! HOW TO EXPANDING?
                    !D(:) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - TEMPPOINT(:,I)
                    D(:) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                    
                    IF(DOT_PRODUCT(DISPLACEMENT(:,I),D)<0) THEN
                        EXPANDING = .TRUE.
                    ELSE
                        EXPANDING = .FALSE.
                    END IF
                    
                    IF(EXPANDING) THEN
                        MU(J) = W(J)
                        LL(J) = A(J)
                    ELSE
                        MU(J) = W(J) * (COSTHETA(J))**2
                        
                        IF(ABS(MU(J))<MINERROR) THEN
                            LL(J) = 0.
                        ELSE
                            LL(J) = A(J) / ABS(COSTHETA(J))
                        END IF
                    END IF
                    
                    IF(ABS(LL(J))>=MINERROR) THEN
                        MU_SUM = MU_SUM + MU(J)
                        LENGTH(I) = LENGTH(I) + MU(J)*LL(J)
                    END IF
                
                END DO
                
                LENGTH(I) = LENGTH(I) / MU_SUM
                
                DEALLOCATE(A)
                DEALLOCATE(W)
                DEALLOCATE(MU)
                DEALLOCATE(LL)
                DEALLOCATE(COSTHETA)
            END IF
        END DO
       
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM 
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))>=MINERROR) DISPLACEMENT(:,I) = LENGTH(I) * DISPLACEMENT(:,I) / SQRT(DOT_PRODUCT(DISPLACEMENT(:,I), DISPLACEMENT(:,I)))  
        END DO
    
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM      
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)  
        END DO
        
        DEALLOCATE(LENGTH)
        DEALLOCATE(FACE_CENTER)
        
        DEALLOCATE(TEMPPOINT)
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)
        
        DEALLOCATE(DISPLACEMENT)
        
    END SUBROUTINE WAVEFRONT_DISPLACEMENT
    
    SUBROUTINE NEAR_CASE_DISPLACEMENT(TYP, DISPLACEMENT)
	IMPLICIT NONE
        INTEGER :: TYP
        REAL(8) :: DISPLACEMENT(:,:)
        REAL(8) :: R, R1, R2, R3
        INTEGER :: I,J,J0,J1, REL, L, L1, N, N0, I1,I2,I3, K
        REAL(8) :: V1(3), V2(3), V(3), NORMAL(3), DIRECTION(3)
        REAL(8) :: TEMP_PT(3)
        REAL(8) :: RMIN
        INTEGER :: NMIN
        INTEGER :: NUM
        LOGICAL :: B,C,D
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            B = .FALSE.
            C = .FALSE.
            DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                J0 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                IF(SURFACE_CURRENT%FACE_ONINTERFACE(J0)==0 .OR. SURFACE_CURRENT%FACE_ONINTERFACE(J0)==1) THEN
                    B = .TRUE.
                ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J0)==2) THEN
                    C = .TRUE.
                END IF
            END DO
            
            IF(B .AND. C) THEN
                
                NUM = 0
                DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                    J0 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                    J1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(MOD(J,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)) + 1,I)
                    IF((SURFACE_CURRENT%FACE_ONINTERFACE(J0)==0 .OR. SURFACE_CURRENT%FACE_ONINTERFACE(J0)==1) &
                       .AND. SURFACE_CURRENT%FACE_ONINTERFACE(J1)==2) THEN
                        DO K=1,3
                            IF(SURFACE_CURRENT%SURFACE_FACES(K,J1)==I) THEN
                                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,J1)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                                NUM = NUM + 1
                                EXIT
                            END IF
                        END DO
                    ELSE IF((SURFACE_CURRENT%FACE_ONINTERFACE(J1)==0 .OR. SURFACE_CURRENT%FACE_ONINTERFACE(J1)==1) &
                       .AND. SURFACE_CURRENT%FACE_ONINTERFACE(J0)==2) THEN
                        DO K=1,3
                            IF(SURFACE_CURRENT%SURFACE_FACES(K,J1)==I) THEN
                                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,J1))
                                NUM = NUM + 1
                                EXIT
                            END IF
                        END DO
                    END IF
                END DO
                !! TESTTEST
                IF(NUM>2) THEN
                    WRITE(*,*) 'ERROR'
                END IF
                !! TESTTEST
                
                V1 = V1 / SQRT(DOT_PRODUCT(V1,V1))
                V2 = V2 / SQRT(DOT_PRODUCT(V2,V2))
                
                V = (V1 + V2)/2.
                V = V / SQRT(DOT_PRODUCT(V,V))
                
                RMIN = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
                NMIN = 0
                
                REL = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)
                
                D = .FALSE.
                DO L=1,3
                    L1 = SURFACE_CASE%SURFACE_FACES(L,REL)
                    DO N=1,SURFACE_CASE%POINT_FACE_CONNECTION_NUM(L1)
                        N0 = SURFACE_CASE%POINT_FACE_CONNECTION(N,L1)
                        
                        I1 = SURFACE_CASE%SURFACE_FACES(1,N0)
                        I2 = SURFACE_CASE%SURFACE_FACES(2,N0)
                        I3 = SURFACE_CASE%SURFACE_FACES(3,N0)
                        
                        V1 = SURFACE_CASE%SURFACE_POINTS(:,I2) - SURFACE_CASE%SURFACE_POINTS(:,I1)
                        V2 = SURFACE_CASE%SURFACE_POINTS(:,I3) - SURFACE_CASE%SURFACE_POINTS(:,I1)
                        
                        CALL VEC_CURL1(V1,V2, NORMAL)
                        NORMAL = NORMAL/SQRT(DOT_PRODUCT(NORMAL,NORMAL))
                        
                        CALL VEC_CURL1(V, NORMAL, DIRECTION)
                        DIRECTION = DIRECTION/SQRT(DOT_PRODUCT(DIRECTION,DIRECTION)) * SURFACE_FLUID%MESH_SIZE/10.
                        
                        CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,I) - DIRECTION, SURFACE_CASE%SURFACE_POINTS(:,I1), SURFACE_CASE%SURFACE_POINTS(:,I2), SURFACE_CASE%SURFACE_POINTS(:,I3), R1)
                        CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,I) + DIRECTION, SURFACE_CASE%SURFACE_POINTS(:,I1), SURFACE_CASE%SURFACE_POINTS(:,I2), SURFACE_CASE%SURFACE_POINTS(:,I3), R2)
                        IF(R1 < SURFACE_FLUID%MESH_SIZE/100.) THEN
                            TEMP_PT = SURFACE_CURRENT%SURFACE_POINTS(:,I) - DIRECTION
                        ELSE IF(R2 < SURFACE_FLUID%MESH_SIZE/100.) THEN
                            TEMP_PT = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DIRECTION
                        ELSE
                            CYCLE
                        END IF
                        
                        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                            J0 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                            IF(SURFACE_CURRENT%FACE_ONINTERFACE(J0)==2) THEN
                                CALL UNSIGNED_DISTANCE_FACE_POINT(TEMP_PT, SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,J0)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,J0)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,J0)), R3)
                                IF(R3 < SURFACE_FLUID%MESH_SIZE/100.) THEN
                                    D = .TRUE.
                                    EXIT
                                END IF
                            END IF
                        END DO
                        
                        IF(D) THEN
                            EXIT
                        END IF
                    END DO
                    
                    IF(D) THEN
                        EXIT
                    END IF
                END DO
                
                DIRECTION = DIRECTION/SQRT(DOT_PRODUCT(DIRECTION,DIRECTION))
                R = SQRT(DOT_PRODUCT(DISPLACEMENT(:,I), DISPLACEMENT(:,I)))
                DISPLACEMENT(:,I) = DIRECTION * R
            END IF
        END DO
        
    END SUBROUTINE NEAR_CASE_DISPLACEMENT
    
    SUBROUTINE NULLSPACE_SMOOTHING(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        
        REAL(8), ALLOCATABLE :: FACE_AREA(:)
        REAL(8), ALLOCATABLE :: FACE_CENTER(:,:)
        
        INTEGER :: I,J,K,L, TEMP_I
        INTEGER :: I1,I2,I3
        REAL(8) :: V1(3),V2(3),R
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        INTEGER :: CON_NUM
        
        INTEGER :: LOCAL_SHAPE
        
        REAL(8), ALLOCATABLE :: N(:,:), W(:), C(:,:)
        REAL(8) :: W_SUM
        
        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        
        INTEGER :: JMIN
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
        
        REAL(8) :: T(3,3), TT(3,3)
        
        REAL(8) :: THETA_A, PHI_C, PHI_R, CHI_C, CHI_R
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        
        ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))
        ALLOCATE(FACE_CENTER(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
	
!	    IF(TYP==0) THEN           
                I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
                I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
                I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
            
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)    

                FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3))/3.
            
                CALL VEC_CURL1(V1,V2, NORMAL(:,I))
            
                R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
                       
                FACE_AREA(I) = R/2.

!if(R < minerror) then
!write(*,*) typ, i1, i2, i3
!write(*,*) surface_current%surface_points(:,i1)
!write(*,*) surface_current%surface_points(:,i2)
!write(*,*) surface_current%surface_points(:,i3)
!write(*,*) surface_current%point_type(i1), surface_current%point_type(i2), surface_current%point_type(i3)
!write(*,*) surface_current%point_relatedface(3,i2), surface_current%point_relatedface(3,i3) 
!write(*,*) surface_case%surface_points(:,surface_case%surface_faces(1,1363)), surface_case%point_type(surface_case%surface_faces(1,1363))
!write(*,*) surface_case%surface_points(:,surface_case%surface_faces(2,1363)), surface_case%point_type(surface_case%surface_faces(2,1363))
!write(*,*) surface_case%surface_points(:,surface_case%surface_faces(3,1363)), surface_case%point_type(surface_case%surface_faces(3,1363))
!end if     

                NORMAL(:,I) = NORMAL(:,I) / R      
!	    ELSE
!                I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
!                I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
!                I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
!		I4 = SURFACE_CURRENT%SURFACE_FACES(4,I)
            
!                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
!                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)    

!                FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3))/3.
            
!                CALL VEC_CURL1(V1,V2, NORMAL(:,I))
            
!                R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
                       
!                FACE_AREA(I) = R/2.
!                NORMAL(:,I) = NORMAL(:,I) / R 
  
!	    END IF

            ! Should modify for square case       
            
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            
            CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))
            ALLOCATE(C(3,CON_NUM))
            
            W_SUM = 0.
            THETA_A = 0.
            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                I1 = SURFACE_CURRENT%SURFACE_FACES(1,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I2 = SURFACE_CURRENT%SURFACE_FACES(2,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I3 = SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF
                
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) / W_SUM
                C(:,J) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            THETA_A = THETA_A - 2.*PI
        
            PHI_R = 10. * PI/180.
            PHI_C = 45. * PI/180.
            
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF
            
            DO J = LOCAL_SHAPE+1, 3
                T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
            END DO
            
            DO K=1,3
                DO L=1,3
                    TT(K,L) = 0.
                    DO J=1,3-LOCAL_SHAPE
                        TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
                    END DO
                END DO
            END DO
            
            DISPLACEMENT(:,I) = 0.
            DO J = 1,CON_NUM
                DO K = 1,3
                    DO L = 1,3
                        DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + W(J)*TT(K,L)*C(L,J)
                    END DO
                END DO
            END DO
            
            DEALLOCATE(N)
            DEALLOCATE(W)
            DEALLOCATE(C)
            
        END DO
        
     !   CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            !IF(SURFACE_CURRENT%INITIAL_POINT_TYPE(I) == 2 .OR. SURFACE_CURRENT%INITIAL_POINT_TYPE(I) == 3) THEN
            IF(SURFACE_CURRENT%INITIAL_POINT_TYPE(I) == 3 .OR. SURFACE_CURRENT%INITIAL_POINT_TYPE(I) == 4 .OR. SURFACE_CURRENT%INITIAL_POINT_TYPE(I) == 5) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO

        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)
        DEALLOCATE(FACE_CENTER)
        
        DEALLOCATE(DISPLACEMENT)
        
    END SUBROUTINE NULLSPACE_SMOOTHING

    SUBROUTINE MODIFIED_NULLSPACE_SMOOTHING(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        INTEGER :: I,J,K,L
        INTEGER :: I1,I2,I3, CON_NUM
        REAL(8) :: V1(3),V2(3)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        !! MODIFIED
        INTEGER :: LOCAL_SHAPE, TEMP_I, JMIN
	REAL(8) :: THETA_A, PHI_R, PHI_C, CHI_R, CHI_C
        !! END MODIFIED
        REAL(8), ALLOCATABLE :: N(:,:), W(:), ORIGIN_W(:), C(:,:), FACE_CENTER(:,:), FACE_AREA(:), T(:,:)
        REAL(8) :: W_SUM, ORIGIN_W_SUM
	REAL(8) :: R

        
        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
        
        REAL(8) :: TT(3,3)
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))        
        ALLOCATE(FACE_CENTER(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM           
            I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
    
            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)    

            FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3))/3.
    
            CALL VEC_CURL1(V1,V2, NORMAL(:,I))
    
            R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
            FACE_AREA(I) = R/2.  
            NORMAL(:,I) = NORMAL(:,I) / R       
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM

            CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))
            ALLOCATE(ORIGIN_W(CON_NUM))
            ALLOCATE(C(3,CON_NUM))
            
            W_SUM = 0.           
	    ORIGIN_W_SUM = 0.
            THETA_A = 0.

            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                ORIGIN_W_SUM = ORIGIN_W_SUM + 1./SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))                
                I1 = SURFACE_CURRENT%SURFACE_FACES(1,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I2 = SURFACE_CURRENT%SURFACE_FACES(2,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I3 = SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF
                
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) / W_SUM
		ORIGIN_W(J) = (1./SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)))/ORIGIN_W_SUM
                C(:,J) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            THETA_A = THETA_A - 2.*PI
        
            PHI_R = 14. * PI/180.
            PHI_C = 10. * PI/180.
            
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF

	    IF(LOCAL_SHAPE .NE. 3) THEN

		ALLOCATE(T(3,3-LOCAL_SHAPE))

		DO J = LOCAL_SHAPE+1, 3
		T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
		END DO

		DO K=1,3
		    DO L=1,3
			TT(K,L) = 0.
			DO J=1,3-LOCAL_SHAPE
			    TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
			END DO
		    END DO
		END DO

		DISPLACEMENT(:,I) = 0.
		DO J = 1,CON_NUM
		    DO K = 1,3
			DO L = 1,3
			    DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + ORIGIN_W(J)*TT(K,L)*C(L,J) !/CON_NUM
			END DO
		    END DO
		END DO
		DEALLOCATE(T)

	    END IF
            
            DEALLOCATE(N)
            DEALLOCATE(W)
	    DEALLOCATE(ORIGIN_W)
            DEALLOCATE(C)
            
        END DO
        
       ! CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SURFACE_CURRENT%INITIAL_POINT_TYPE(I) == 3) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO

        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)  
        DEALLOCATE(FACE_CENTER)
        
        DEALLOCATE(DISPLACEMENT)
        
    END SUBROUTINE MODIFIED_NULLSPACE_SMOOTHING
    


    SUBROUTINE SQUARE_NULLSPACE_SMOOTHING(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        INTEGER :: I,J,K,L
        INTEGER :: I1,I2,I3,I4, CON_NUM
        REAL(8) :: V1(3),V2(3)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        !! MODIFIED
        INTEGER :: LOCAL_SHAPE, TEMP_I, JMIN
	REAL(8) :: THETA_A, PHI_R, PHI_C, CHI_R, CHI_C
        !! END MODIFIED
        REAL(8), ALLOCATABLE :: N(:,:), W(:), ORIGIN_W(:), C(:,:), FACE_CENTER(:,:), FACE_AREA(:), T(:,:)
        REAL(8) :: W_SUM, ORIGIN_W_SUM
	REAL(8) :: R

        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
        REAL(8) :: TT(3,3), TEMP_VECTOR(3)
	INTEGER, ALLOCATABLE :: FACE(:,:), CONNECTION(:,:), CONNECTION_NUM(:)
	REAL(8), ALLOCATABLE :: INITIAL_AREA(:)
	INTEGER :: FACE_NUM
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
	
	FACE_NUM = SURFACE_CURRENT%SURFACE_FACES_NUM/2

        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        ALLOCATE(FACE_AREA(FACE_NUM))        
        ALLOCATE(FACE_CENTER(3,FACE_NUM))
        ALLOCATE(NORMAL(3,FACE_NUM))
        ALLOCATE(FACE(4,FACE_NUM))
	ALLOCATE(CONNECTION(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(CONNECTION_NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(INITIAL_AREA(FACE_NUM))
	DISPLACEMENT = 0
	FACE_AREA = 0
	FACE_CENTER = 0
	NORMAL = 0
	FACE = 0
        CONNECTION = 0
	CONNECTION_NUM = 0
	INITIAL_AREA = 0

        DO I=1,FACE_NUM
            FACE(1,I) = SURFACE_CURRENT%SURFACE_FACES(1,2*I-1)
            FACE(2,I) = SURFACE_CURRENT%SURFACE_FACES(2,2*I-1)
            FACE(3,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I-1)
            FACE(4,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I)
            INITIAL_AREA(I) = SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I-1) + SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I)
        END DO

        DO I=1,FACE_NUM
            DO J=1,4
		CONNECTION_NUM(FACE(J,I)) = CONNECTION_NUM(FACE(J,I)) + 1
		CONNECTION(CONNECTION_NUM(FACE(J,I)),FACE(J,I)) = I
            END DO
        END DO

        DO I=1,FACE_NUM           
            I1 = FACE(1,I)
            I2 = FACE(2,I)
            I3 = FACE(3,I)
	    I4 = FACE(4,I)

            FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3) + SURFACE_CURRENT%SURFACE_POINTS(:,I4))/4.

            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)    
            CALL VEC_CURL1(V1,V2, TEMP_VECTOR)
            R = SQRT(DOT_PRODUCT(TEMP_VECTOR, TEMP_VECTOR))
            FACE_AREA(I) = R/2.  
            NORMAL(:,I) = TEMP_VECTOR / R

	    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I4) - SURFACE_CURRENT%SURFACE_POINTS(:,I3)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I1) - SURFACE_CURRENT%SURFACE_POINTS(:,I3)    
            CALL VEC_CURL1(V1,V2, TEMP_VECTOR)
            R = SQRT(DOT_PRODUCT(TEMP_VECTOR, TEMP_VECTOR))
            FACE_AREA(I) = FACE_AREA(I) + R/2.  
            NORMAL(:,I) = (TEMP_VECTOR / R + NORMAL(:,I))/2.0
        END DO
        

        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM

            CON_NUM = CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))
            ALLOCATE(ORIGIN_W(CON_NUM))
            ALLOCATE(C(3,CON_NUM))
            
            W_SUM = 0.           
	    ORIGIN_W_SUM = 0.
            THETA_A = 0.

            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(CONNECTION(J,I))
                ORIGIN_W_SUM = ORIGIN_W_SUM + 1./INITIAL_AREA(CONNECTION(J,I))                
                
                IF(I==I1) THEN
		I1 = FACE(1,CONNECTION(J,I))
                I2 = FACE(2,CONNECTION(J,I))
                I3 = FACE(3,CONNECTION(J,I))
                I4 = FACE(4,CONNECTION(J,I))
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = FACE(2,CONNECTION(J,I))
                    I2 = FACE(3,CONNECTION(J,I))
                    I3 = FACE(4,CONNECTION(J,I))
                    I4 = FACE(1,CONNECTION(J,I))
                ELSE IF(I==I3) THEN
                    TEMP_I = I2
                    I1 = FACE(3,CONNECTION(J,I))
                    I2 = FACE(4,CONNECTION(J,I))
                    I3 = FACE(1,CONNECTION(J,I))
                    I4 = FACE(2,CONNECTION(J,I))
                ELSE
                    TEMP_I = I3
                    I1 = FACE(4,CONNECTION(J,I))
                    I2 = FACE(1,CONNECTION(J,I))
                    I3 = FACE(2,CONNECTION(J,I))
                    I4 = FACE(3,CONNECTION(J,I))
                END IF
                
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I4) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,CONNECTION(J,I))
                W(J) = FACE_AREA(CONNECTION(J,I)) / W_SUM
		ORIGIN_W(J) = (1./INITIAL_AREA(CONNECTION(J,I)))/ORIGIN_W_SUM
                C(:,J) = FACE_CENTER(:,CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            THETA_A = THETA_A - 2.*PI
            PHI_R = 10. * PI/180.
            PHI_C = 45. * PI/180.
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF

	    IF(LOCAL_SHAPE .NE. 3) THEN

		ALLOCATE(T(3,3-LOCAL_SHAPE))

		DO J = LOCAL_SHAPE+1, 3
		T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
		END DO

		DO K=1,3
		    DO L=1,3
			TT(K,L) = 0.
			DO J=1,3-LOCAL_SHAPE
			    TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
			END DO
		    END DO
		END DO

		DISPLACEMENT(:,I) = 0.
		DO J = 1,CON_NUM
		    DO K = 1,3
			DO L = 1,3
			    DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + ORIGIN_W(J)*TT(K,L)*C(L,J)!/CON_NUM
			END DO
		    END DO
		END DO
		DEALLOCATE(T)

	    END IF
            
            DEALLOCATE(N)
            DEALLOCATE(W)
	    DEALLOCATE(ORIGIN_W)
            DEALLOCATE(C)
            
        END DO
        
        ! CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            !IF(SURFACE_CURRENT%INITIAL_POINT_TYPE(I) == 2 .OR. SURFACE_CURRENT%INITIAL_POINT_TYPE(I) == 3) THEN
            IF(SURFACE_CURRENT%INITIAL_POINT_TYPE(I) == 3) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO

        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)  
        DEALLOCATE(FACE_CENTER)
        DEALLOCATE(DISPLACEMENT)
        DEALLOCATE(FACE)
	DEALLOCATE(CONNECTION_NUM)
	DEALLOCATE(CONNECTION)
	DEALLOCATE(INITIAL_AREA)
        
    END SUBROUTINE SQUARE_NULLSPACE_SMOOTHING


    SUBROUTINE GEOMETRIC_FLOW_SMOOTHING(TYP,TIME_STEP)
        IMPLICIT NONE
        
	INTEGER :: TYP
	INTEGER :: FACE_NUM, TEMP, POINT_NUM
	INTEGER :: I,J,K,L, I1,I2,I3, J0, J1, FACE_INDEX, IDX
	INTEGER, ALLOCATABLE :: CONNECTION(:,:), CONNECTION_NUM(:), FACE(:,:), POINT_IDX(:,:), FACE_IDX(:), POINT_INDEX(:), NUM(:)
	REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:), FACE_AREA(:), POINT_NORMAL(:,:,:), POINT_NEIGHBOR(:,:)
	REAL(8) :: U, V, Q, TIME_STEP
	REAL(8) :: POINT(3,4), TEMPPOINT(3)
        REAL(8) :: V1(3), V2(3), V3(3), W1(3), W2(3), Q1(4), Q2(4)
	REAL(8) :: F, AREA
	REAL(8) :: SU(3), SV(3), TEMPVEC(3)
	REAL(8), ALLOCATABLE :: NORMAL(:,:), ALPHA(:), BETA(:), DELTA(:), ALPHA_21(:), ALPHA_43(:), ALPHA_31(:), ALPHA_42(:), WEIGHT(:,:), H(:,:), R1(:,:), MASS_CENTER(:,:), TEMP_POINT(:,:), SURF_POINT(:,:)
	REAL(8) :: AREA_SUM
    
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF

        ALLOCATE(SURF_POINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        
        SURF_POINT = SURFACE_CURRENT%SURFACE_POINTS
        
	FACE_NUM = SURFACE_CURRENT%SURFACE_FACES_NUM/2

        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        ALLOCATE(FACE_AREA(FACE_NUM))        
        ALLOCATE(FACE(4,FACE_NUM))

	DISPLACEMENT = 0.
	FACE_AREA = 0.
	FACE = 0
   
	!RECOVER QUAD MESH FROM TRIANGULAR MESH	
        DO I=1,FACE_NUM
            FACE(1,I) = SURFACE_CURRENT%SURFACE_FACES(1,2*I-1)
            FACE(2,I) = SURFACE_CURRENT%SURFACE_FACES(2,2*I-1)
            FACE(3,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I-1)
            FACE(4,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I)
        END DO

	ALLOCATE(CONNECTION(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(CONNECTION_NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    CONNECTION = 0
    CONNECTION_NUM = 0

        DO I=1,FACE_NUM
            DO J=1,4
		CONNECTION_NUM(FACE(J,I)) = CONNECTION_NUM(FACE(J,I)) + 1
		CONNECTION(CONNECTION_NUM(FACE(J,I)),FACE(J,I)) = I
            END DO
        END DO
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM      
            ALLOCATE(POINT_INDEX(CONNECTION_NUM(I)))
            POINT_INDEX = 0
            DO J=1,CONNECTION_NUM(I)
                J0 = CONNECTION(J,I)
                DO K=1,4
                    IF(FACE(K,J0)==I) THEN
                        POINT_INDEX(J) = K
                        EXIT
                    END IF
                END DO
            END DO
            
            DO J=1,CONNECTION_NUM(I)
                J0 = CONNECTION(J,I)
                I1 = FACE(MOD(POINT_INDEX(J)+2,4)+1, J0)
                DO K=J+1,CONNECTION_NUM(I)
                    J1 = CONNECTION(K,I)
                    I2 = FACE(MOD(POINT_INDEX(K),4)+1, J1)
                    IF(I1==I2) THEN
                       TEMP = CONNECTION(J+1,I)
                       CONNECTION(J+1,I) = CONNECTION(K,I)
                       CONNECTION(K,I) = TEMP
                       
                       TEMP = POINT_INDEX(J+1)
                       POINT_INDEX(J+1) = POINT_INDEX(K)
                       POINT_INDEX(K) = TEMP
                       
                       EXIT
                    END IF
                END DO
            END DO
            DEALLOCATE(POINT_INDEX)
    END DO        
	!DEFINING QUADRATURE POINTS
        
    Q1 = (/-1.0, 1.0, -1.0, 1.0/)
    Q2 = (/-1.0, -1.0, 1.0, 1.0/)
    Q  = SQRT(3.0)/6.0

	POINT = 0.

	!COMPUTING AREA OF QUAD ELEMENT(INCLUDING NON-COPLANAR CASE)
	DO I = 1, FACE_NUM
	    POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(1,I))
	    POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(2,I))
	    POINT(:,4) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(3,I))
	    POINT(:,3) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(4,I))
	    DO K = 1, 4
            U = 0.5 + Q1(K)*Q
            V = 0.5 + Q2(K)*Q
            SU = (1-V)*(POINT(:,2)-POINT(:,1)) + V*(POINT(:,4)-POINT(:,3))
            SV = (1-U)*(POINT(:,3)-POINT(:,1)) + U*(POINT(:,4)-POINT(:,2))
		    CALL VEC_CURL1(SU,SV,TEMPVEC)
		    F = SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
		    FACE_AREA(I) = FACE_AREA(I) + F/4.
	   END DO
	END DO

        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        NORMAL = 0.
        !COMPUTING NORMALS
        DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
            AREA_SUM = 0.
            DO J = 1, CONNECTION_NUM(I)
                IDX = CONNECTION(J,I)
                AREA_SUM = AREA_SUM + FACE_AREA(IDX)
                DO K = 1, 4
                    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(K,IDX))
                    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(MOD(K,4)+1,IDX))
                    V3 = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(MOD(K+1,4)+1,IDX))
                    W1 = V2 - V1
                    W2 = V3 - V1
                    CALL VEC_CURL1(W1,W2,TEMPVEC)
                    NORMAL(:,I) = NORMAL(:,I) + FACE_AREA(IDX)*TEMPVEC
                END DO
            END DO
            NORMAL(:,I) = NORMAL(:,I)/AREA_SUM
            NORMAL(:,I) = NORMAL(:,I)/SQRT(DOT_PRODUCT(NORMAL(:,I),NORMAL(:,I)))
        END DO

	!APPROXIMATING THE MEAN CURVATURE TERM AND THE TANGENT TERM

	ALLOCATE(H(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(R1(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(MASS_CENTER(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(WEIGHT(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        ALLOCATE(NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(POINT_IDX(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(POINT_NORMAL(3,30,SURFACE_CURRENT%SURFACE_POINTS_NUM))	
	H = 0.
	R1 = 0.
	MASS_CENTER = 0.
	WEIGHT = 0.
	NUM = 0
	POINT_IDX = 0
	POINT_NORMAL = 0.    
	
    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        IF(SURFACE_CURRENT%POINT_TYPE(I)==1 .OR. SURFACE_CURRENT%POINT_TYPE(I)==2) THEN
	    NUM(I) = CONNECTION_NUM(I)
        ALLOCATE(POINT_NEIGHBOR(3,2*NUM(I)))
	    ALLOCATE(ALPHA_21(NUM(I)))
	    ALLOCATE(ALPHA_43(NUM(I)))
	    ALLOCATE(ALPHA_31(NUM(I)))
	    ALLOCATE(ALPHA_42(NUM(I)))
	    ALLOCATE(ALPHA(NUM(I)))
	    ALLOCATE(BETA(NUM(I)))
	    ALLOCATE(DELTA(NUM(I)))
	    ALLOCATE(FACE_IDX(2*NUM(I)))
        ALPHA_21 = 0.
	    ALPHA_43 = 0.
	    ALPHA_31 = 0.
	    ALPHA_42 = 0.
	    ALPHA = 0.
	    BETA = 0.
	    DELTA = 0.
	    AREA_SUM = 0.
        POINT_NEIGHBOR = 0.

	    DO J = 1, NUM(I)
            FACE_INDEX = CONNECTION(J,I)
            AREA = FACE_AREA(FACE_INDEX)
		    AREA_SUM = AREA_SUM + FACE_AREA(FACE_INDEX)
		    
            DO K = 1, 4
		        TEMP = FACE(K,FACE_INDEX)
		        IF(TEMP==I) THEN
			        IDX = K
			    EXIT
		        END IF
            END DO
		
            IF(IDX==1) THEN
		        I1 = 2
		        I2 = 3
		        I3 = 4
		    ELSEIF(IDX==2) THEN
		        I1 = 3
		        I2 = 4
		        I3 = 1
		    ELSEIF(IDX==3) THEN
		        I1 = 4
		        I2 = 1
		        I3 = 2
		    ELSE
		        I1 = 1
		        I2 = 2
		        I3 = 3
            END IF
            
            TEMPPOINT = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(IDX,FACE_INDEX))
            IF(I .NE. FACE(IDX,FACE_INDEX)) THEN
                WRITE(*,*) 'ERROR IN GEOMETRIC_SMOOTHING, CHECK INDEXES'
            END IF
                              
            POINT_NEIGHBOR(:,2*J-1) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(I1,FACE_INDEX))
            POINT_NORMAL(:,2*J-1,I) = NORMAL(:,FACE(I1,FACE_INDEX))
            POINT_IDX(2*J-1,I) = FACE(I1,FACE_INDEX)
		   
            POINT_NEIGHBOR(:,2*J) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(I2,FACE_INDEX))
            POINT_NORMAL(:,2*J,I) = NORMAL(:,FACE(I2,FACE_INDEX))
            POINT_IDX(2*J,I) = FACE(I2,FACE_INDEX)

            POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I))) = SURFACE_CURRENT%SURFACE_POINTS(:,FACE(I3,FACE_INDEX))
            POINT_NORMAL(:,MOD(2*J+1,2*NUM(I)),I) = NORMAL(:,FACE(I3,FACE_INDEX))
            POINT_IDX(MOD(2*J+1,2*NUM(I)),I) = FACE(I3,FACE_INDEX)  

		    !COMPUTING ALPHA_21, ALPHA_43, ALPHA_31, ALPHA_42 FOR EACH FACE ADJACENT TO ITH POINT.
		    ALPHA_21 = 0.
		    ALPHA_43 = 0.
		    ALPHA_31 = 0.
		    ALPHA_42 = 0.
           
	        DO K = 1, 4
                U = 0.5 + Q1(K)*Q
                V = 0.5 + Q2(K)*Q                
                SU = (1-V)*(POINT_NEIGHBOR(:,2*J-1)-TEMPPOINT) + V*(POINT_NEIGHBOR(:,2*J)-POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I))))
                SV = (1-U)*(POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I)))-TEMPPOINT) + U * (POINT_NEIGHBOR(:,2*J)-POINT_NEIGHBOR(:,2*J-1))
		        CALL VEC_CURL1(SU,SV,TEMPVEC)
		        F = SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
		        ALPHA_21(J) = ALPHA_21(J) + ((1.- V)*DOT_PRODUCT(SV,(V-1.)*SV-(1.-U)*SU))/(4.*F)
		        ALPHA_43(J) = ALPHA_43(J) + (V*DOT_PRODUCT(SV,(V-1.)*SV-(U-1.)*SU))/(4.*F)
		        ALPHA_31(J) = ALPHA_31(J) + ((1.-U)*DOT_PRODUCT(SU,(U-1.)*SU-(V-1.)*SV))/(4.*F)
		        ALPHA_42(J) = ALPHA_42(J) + (U*DOT_PRODUCT(SU,(U-1.)*SU-(V-1.)*SV))/(4.*F)
	        END DO

		    ALPHA(J) = ALPHA_21(J) - ALPHA_42(J)
		    BETA(J) = ALPHA_31(J) - ALPHA_43(J)
		    DELTA(J) = ALPHA_43(J) + ALPHA_42(J)

	        H(:,I) = H(:,I) + ALPHA(J)*(POINT_NEIGHBOR(:,2*J-1)-TEMPPOINT) + BETA(J)*(POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I)))-TEMPPOINT) + DELTA(J)*(POINT_NEIGHBOR(:,2*J)-TEMPPOINT) 
            MASS_CENTER(:,I) = MASS_CENTER(:,I) + (TEMPPOINT+POINT_NEIGHBOR(:,2*J-1)+POINT_NEIGHBOR(:,2*J)+POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I))))*AREA/4.
                
        END DO
        MASS_CENTER(:,I) = MASS_CENTER(:,I)/AREA_SUM
        
        H(:,I) = H(:,I)/AREA_SUM
        R1(:,I) = R1(:,I) + (MASS_CENTER(:,I)-TEMPPOINT)-DOT_PRODUCT(NORMAL(:,I),MASS_CENTER(:,I)-TEMPPOINT)*NORMAL(:,I)
        
        DO L = 1, NUM(I)
		    IF(L==1) THEN
		        WEIGHT(2*L-1,I) = ALPHA(L)
		        WEIGHT(2*L,I) = DELTA(L)
            ELSEIF(L==NUM(I)) THEN
		        WEIGHT(2*L,I) = DELTA(L)            
            ELSE
		        WEIGHT(2*L-1,I) = ALPHA(L) + BETA(L-1)
		        WEIGHT(2*L,I) = DELTA(L)
		        WEIGHT(2*L+1,I) = ALPHA(L+1) + BETA(L)
		    END IF
        END DO

	   WEIGHT(:,I) = WEIGHT(:,I)/AREA_SUM

        DEALLOCATE(POINT_NEIGHBOR)
	DEALLOCATE(ALPHA_21)
	DEALLOCATE(ALPHA_43)
	DEALLOCATE(ALPHA_31)
	DEALLOCATE(ALPHA_42)
	DEALLOCATE(ALPHA)
	DEALLOCATE(BETA)
	DEALLOCATE(DELTA)
        DEALLOCATE(FACE_IDX)
        END IF
    END DO
   
 !   DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
 !       DO L = 1, 2*NUM(I)
 !           TEMP = DOT_PRODUCT(POINT_NORMAL(:,L,I),H(:,POINT_IDX(L,I)))
 !	        R1(:,I) = R1(:,I) + 2*WEIGHT(L,I)*(TEMP*NORMAL(:,I)-H(:,I))
 !       END DO
 !   END DO

        !TIME-INTEGRATION

    ALLOCATE(TEMP_POINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    
    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
       SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + TIME_STEP/10.*R1(:,I)
    END DO
    
    DEALLOCATE(DISPLACEMENT)
    DEALLOCATE(FACE_AREA)        
    DEALLOCATE(FACE)
    DEALLOCATE(CONNECTION)
    DEALLOCATE(CONNECTION_NUM)
    DEALLOCATE(H)
    DEALLOCATE(R1)
    DEALLOCATE(MASS_CENTER)
    DEALLOCATE(NORMAL)
    DEALLOCATE(NUM)
    DEALLOCATE(POINT_IDX)
    DEALLOCATE(POINT_NORMAL)
    DEALLOCATE(WEIGHT)

    END SUBROUTINE GEOMETRIC_FLOW_SMOOTHING
    
       SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TRIANGLE(TYP,TIME_STEP)
        IMPLICIT NONE
        
	INTEGER :: TYP
	INTEGER :: FACE_NUM, TEMP, POINT_NUM
	INTEGER :: I,J,K, I1,I2, FACE_INDEX, IDX
	INTEGER, ALLOCATABLE :: FACE_IDX(:), NUM(:)
	REAL(8), ALLOCATABLE :: FACE_AREA(:), POINT_NEIGHBOR(:,:)
	REAL(8) :: TIME_STEP
	REAL(8) :: POINT(3,3), TEMPPOINT(3)
    REAL(8) :: V1(3), V2(3), V3(3), W1(3), W2(3)
	REAL(8) :: AREA
	REAL(8) :: TEMPVEC(3)
	REAL(8), ALLOCATABLE :: NORMAL(:,:), R1(:,:), MASS_CENTER(:,:)
	REAL(8) :: AREA_SUM
    
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF

        ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))        

	FACE_AREA = 0.
	POINT = 0.

	!COMPUTING AREA OF QUAD ELEMENT(INCLUDING NON-COPLANAR CASE)
	DO I = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
	    POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,I))
	    POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,I))
	    POINT(:,3) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,I))
        
        W1 = POINT(:,2) - POINT(:,1)
        W2 = POINT(:,3) - POINT(:,1)
        CALL VEC_CURL1(W1,W2,TEMPVEC)
        FACE_AREA(I) = SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))/2.

    END DO
    
    

        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        NORMAL = 0.
        !COMPUTING NORMALS
        DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
            AREA_SUM = 0.
            DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                AREA_SUM = AREA_SUM + FACE_AREA(IDX)
                DO K = 1, 3
                    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,IDX))
                    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,IDX))
                    V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,IDX))
                    W1 = V2 - V1
                    W2 = V3 - V1
                    CALL VEC_CURL1(W1,W2,TEMPVEC)
                    NORMAL(:,I) = NORMAL(:,I) + FACE_AREA(IDX)*TEMPVEC
                END DO
            END DO
            NORMAL(:,I) = NORMAL(:,I)/AREA_SUM
            NORMAL(:,I) = NORMAL(:,I)/SQRT(DOT_PRODUCT(NORMAL(:,I),NORMAL(:,I)))
        END DO

	!APPROXIMATING THE MEAN CURVATURE TERM AND THE TANGENT TERM

	ALLOCATE(R1(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	ALLOCATE(MASS_CENTER(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))

	R1 = 0.
	MASS_CENTER = 0.
	NUM = 0
	
    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        IF(SURFACE_CURRENT%POINT_TYPE(I)==1 .OR. SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==4) THEN
	    NUM(I) = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
        ALLOCATE(POINT_NEIGHBOR(3,NUM(I)))

       AREA_SUM = 0.
        POINT_NEIGHBOR = 0.

	    DO J = 1, NUM(I)
            FACE_INDEX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            AREA = FACE_AREA(FACE_INDEX)
		    AREA_SUM = AREA_SUM + FACE_AREA(FACE_INDEX)
		    
            DO K = 1, 3
		        TEMP = SURFACE_CURRENT%SURFACE_FACES(K,FACE_INDEX)
		        IF(TEMP==I) THEN
			        IDX = K
			    EXIT
		        END IF
            END DO
		
            IF(IDX==1) THEN
		        I1 = 2
		        I2 = 3
		    ELSEIF(IDX==2) THEN
		        I1 = 3
		        I2 = 1
		    ELSE
		        I1 = 1
		        I2 = 2
            END IF
            
            TEMPPOINT = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(IDX,FACE_INDEX))
                              
            POINT_NEIGHBOR(:,J) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(I1,FACE_INDEX))
		   
            POINT_NEIGHBOR(:,MOD(J,NUM(I))+1) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(I2,FACE_INDEX))

            MASS_CENTER(:,I) = MASS_CENTER(:,I) + (TEMPPOINT+POINT_NEIGHBOR(:,J)+POINT_NEIGHBOR(:,MOD(J,NUM(I))+1))*AREA/3.
                
        END DO
        
        MASS_CENTER(:,I) = MASS_CENTER(:,I)/AREA_SUM
        R1(:,I) = R1(:,I) + (MASS_CENTER(:,I)-TEMPPOINT)-DOT_PRODUCT(NORMAL(:,I),MASS_CENTER(:,I)-TEMPPOINT)*NORMAL(:,I)     

        DEALLOCATE(POINT_NEIGHBOR)
	END IF
    END DO
      
    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
       SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + TIME_STEP/100.*R1(:,I)
    END DO
    
    DEALLOCATE(FACE_AREA)        
    DEALLOCATE(R1)
    DEALLOCATE(MASS_CENTER)
    DEALLOCATE(NORMAL)
    DEALLOCATE(NUM)

    END SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TRIANGLE
    
    
    SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        
        
        !CALL BOUNDARY_DIVIDING(TYP)
        
        CALL NEW_MODIFIED_NULLSPACE_SMOOTHING(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA, SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH, SURFACE_CURRENT%POINT_TYPE, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)
        
    END SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP
    
    
    
    SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, TEMP_NEWEDGELENGTH, TEMPPOINT_TYPE, DIVIDED_BOUNDARY_ARRAY)
	IMPLICIT NONE
        INTEGER :: TEMP_POINT_NUM
        REAL(8) :: TEMPPOINT(:,:)
        INTEGER :: TEMP_FACE_NUM
        INTEGER :: TEMPFACE(:,:)
        
        INTEGER :: TEMP_CONNECTION(:,:)
        INTEGER :: TEMP_CONNECTION_NUM(:)
        REAL(8) :: TEMP_NEWFACEAREA(:)
        REAL(8) :: TEMP_NEWEDGELENGTH(:,:)
        INTEGER :: TEMPPOINT_TYPE(:)
        INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
        
        
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        INTEGER :: I,J,K,L
        INTEGER :: I1,I2,I3, CON_NUM
        REAL(8) :: V1(3),V2(3)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        !! MODIFIED
        INTEGER :: LOCAL_SHAPE, TEMP_I, JMIN
	REAL(8) :: THETA_A, PHI_R, PHI_C, CHI_R, CHI_C
        !! END MODIFIED
        REAL(8), ALLOCATABLE :: N(:,:), W(:), ORIGIN_W(:), C(:,:), FACE_CENTER(:,:), FACE_AREA(:), T(:,:)
        REAL(8) :: CC(3)
        INTEGER :: RIDGE_EDGE_NUM, RIDGE_EDGE(2,10)
        
        REAL(8) :: W_SUM, ORIGIN_W_SUM
	REAL(8) :: R

        
        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
        
        REAL(8) :: TT(3,3)
        
        
        ALLOCATE(DISPLACEMENT(3,TEMP_POINT_NUM))
        ALLOCATE(FACE_AREA(TEMP_FACE_NUM))        
        ALLOCATE(FACE_CENTER(3,TEMP_FACE_NUM))
        ALLOCATE(NORMAL(3,TEMP_FACE_NUM))
        
        DO I=1,TEMP_FACE_NUM           
            I1 = TEMPFACE(1,I)
            I2 = TEMPFACE(2,I)
            I3 = TEMPFACE(3,I)
    
            V1 = TEMPPOINT(:,I2) - TEMPPOINT(:,I1)
            V2 = TEMPPOINT(:,I3) - TEMPPOINT(:,I1)    

            FACE_CENTER(:,I) = (TEMPPOINT(:,I1) + TEMPPOINT(:,I2) + TEMPPOINT(:,I3))/3.
    
            CALL VEC_CURL1(V1,V2, NORMAL(:,I))
    
            R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
            FACE_AREA(I) = R/2.  
            NORMAL(:,I) = NORMAL(:,I) / R       
        END DO
        
        DO I=1,TEMP_POINT_NUM

            CON_NUM = TEMP_CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))
            ALLOCATE(ORIGIN_W(CON_NUM))
            ALLOCATE(C(3,CON_NUM))
            
            W_SUM = 0.           
	    ORIGIN_W_SUM = 0.
            THETA_A = 0.

            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(TEMP_CONNECTION(J,I))             
                I1 = TEMPFACE(1,TEMP_CONNECTION(J,I))
                I2 = TEMPFACE(2,TEMP_CONNECTION(J,I))
                I3 = TEMPFACE(3,TEMP_CONNECTION(J,I))
                
                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF
                
                V1 = TEMPPOINT(:,I2) - TEMPPOINT(:,I1)
                V2 = TEMPPOINT(:,I3) - TEMPPOINT(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,TEMP_CONNECTION(J,I))
                W(J) = FACE_AREA(TEMP_CONNECTION(J,I)) / W_SUM
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            THETA_A = THETA_A - 2.*PI
        
            PHI_R = 14. * PI/180.
            PHI_C = 45. * PI/180.
            
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF
            
            RIDGE_EDGE_NUM = 0
            
            DO J=1,CON_NUM
                L = TEMP_CONNECTION(J,I)
                DO K=1,3
                    IF(TEMPFACE(K,L)==I) THEN
                        EXIT
                    END IF
                END DO
                
                IF(DIVIDED_BOUNDARY_ARRAY(K,L) .NE. 0) THEN
                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = K
                    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = L
                END IF
            END DO
            
            IF(RIDGE_EDGE_NUM > 2 .OR. RIDGE_EDGE_NUM == 1) THEN
                CC(:) = 0.
            ELSE IF(RIDGE_EDGE_NUM == 0) THEN
                DO J = 1,CON_NUM
                    ORIGIN_W_SUM = ORIGIN_W_SUM + 1./TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I))
                END DO
                
                DO J = 1,CON_NUM
                    ORIGIN_W(J) = (1./TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I)))/ORIGIN_W_SUM
                    C(:,J) = FACE_CENTER(:,TEMP_CONNECTION(J,I)) - TEMPPOINT(:,I)
                END DO
                
                CC(:) = 0.
                DO J = 1,CON_NUM
                    CC(:) = CC(:) + W(J) * C(:,J)/3.
                END DO
            ELSE IF(RIDGE_EDGE_NUM == 2 .AND. DIVIDED_BOUNDARY_ARRAY(RIDGE_EDGE(1,1), RIDGE_EDGE(2,1)) == DIVIDED_BOUNDARY_ARRAY(RIDGE_EDGE(1,2) , RIDGE_EDGE(2,2)) ) THEN
                DO J = 1,2
                    ORIGIN_W_SUM = ORIGIN_W_SUM + 1./TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J))
                END DO
                
                DO J = 1,2
                    ORIGIN_W(J) = (1./TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J)))/ORIGIN_W_SUM
                    I1 = TEMPFACE(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J))
                    I2 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1, RIDGE_EDGE(2,J))
                    C(:,J) = (TEMPPOINT(:,I1)+TEMPPOINT(:,I2))/2. - TEMPPOINT(:,I)
                END DO
                
                CC(:) = 0.
                DO J = 1,2
                    CC(:) = CC(:) + ORIGIN_W(J) * C(:,J)/3.
                END DO
            ELSE
                CC(:) = 0.
            END IF
            
            IF(TEMPPOINT_TYPE(I)==5) THEN
                TT(:,:) = 0.
            ELSE IF(TEMPPOINT_TYPE(I)==4) THEN
                
                ALLOCATE(T(3,1))
                
                K = 0
                DO J=1,RIDGE_EDGE_NUM
                    IF(TEMPPOINT_TYPE(TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1,RIDGE_EDGE(2,J)))>=4) THEN
                        K = K + 1
                        IF(K==1) THEN
                            I1 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1,RIDGE_EDGE(2,J))
                        ELSE
                            I2 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1,RIDGE_EDGE(2,J))
                            EXIT
                        END IF
                    END IF
                END DO
                
                T(:,1) = TEMPPOINT(:,I1) - TEMPPOINT(:,I2)
                
                DO K=1,3
                    DO L=1,3
                        TT(K,L) = TT(K,L) + T(K,1)*T(L,1)
                    END DO
                END DO
                
                DEALLOCATE(T)
                
            ELSE IF(LOCAL_SHAPE .NE. 3) THEN
                
                ALLOCATE(T(3,3-LOCAL_SHAPE))
                
                DO J = LOCAL_SHAPE+1, 3
                    T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
                END DO
                
                DO K=1,3
                    DO L=1,3
                        TT(K,L) = 0.
                        DO J=1,3-LOCAL_SHAPE
                            TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
                        END DO
                    END DO
                END DO
                
                DEALLOCATE(T)
            ELSE
                TT(:,:) = 0.
            END IF
            
            DISPLACEMENT(:,I) = 0.
            
            DO K = 1,3
                DO L = 1,3
                    DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + TT(K,L)*CC(L)
                END DO
            END DO
            
            DEALLOCATE(N)
            DEALLOCATE(W)
	    DEALLOCATE(ORIGIN_W)
            DEALLOCATE(C)
            
        END DO
        
       ! CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TEMP_POINT_NUM
            IF(TEMPPOINT_TYPE(I) == 3) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO

        DO I = 1,TEMP_POINT_NUM
            TEMPPOINT(:,I) = TEMPPOINT(:,I) + DISPLACEMENT(:,I)
        END DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)  
        DEALLOCATE(FACE_CENTER)
        
        DEALLOCATE(DISPLACEMENT)
        
        
    END SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING

    SUBROUTINE FACEOFFSETTING_3D(TYP, TIMESTEP)
        IMPLICIT NONE
        INTEGER :: TYP
        REAL(8) :: TIMESTEP
        REAL(8), ALLOCATABLE :: TEMPPOINT(:,:)
        INTEGER :: I
        REAL(8) :: AXIS(3)

        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(TEMPPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            TEMPPOINT(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
        END DO
        !$OMP END PARALLEL DO
      
        CALL WAVEFRONT_DISPLACEMENT(TYP, TIMESTEP)   

	!CALL MODIFIED_NULLSPACE_SMOOTHING(TYP)

	DO I=1,10
	    CALL GEOMETRIC_FLOW_SMOOTHING_TRIANGLE(TYP,TIMESTEP)
	END DO

	!CALL NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(TYP)
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%POINT_VELOCITY(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) - TEMPPOINT(:,I)
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = TEMPPOINT(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        DEALLOCATE(TEMPPOINT)
 
    END SUBROUTINE FACEOFFSETTING_3D



    SUBROUTINE MAINTAIN_CASE_CORNER()
        IMPLICIT NONE
        INTEGER :: I, J, K, I1
        INTEGER :: JMIN
        REAL(8) :: R, RMIN
        LOGICAL :: B, C
        
        DO I = 1,SURFACE_CASE%SURFACE_POINTS_NUM
            IF(SURFACE_CASE%INITIAL_POINT_TYPE(I)==3) THEN
                B = .TRUE.
                DO J=1,SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I)
                    I1 = SURFACE_CASE%POINT_FACE_CONNECTION(J,I)
                    IF(SURFACE_CASE%FACE_ONINTERFACE(I1) .NE. 0) THEN
                        B = .FALSE.
                    END IF
                END DO
                IF(B) THEN
                    RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
                    JMIN = 0
                    DO J = 1,SURFACE_FLUID%SURFACE_POINTS_NUM
                        C = .FALSE.
                        DO K = 1,SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I)
                            IF(SURFACE_FLUID%POINT_RELATEDFACE(2+1,J)==SURFACE_CASE%POINT_FACE_CONNECTION(K,I)) THEN
                                C = .TRUE.
                            END IF
                        END DO
                        IF(SURFACE_FLUID%INITIAL_POINT_TYPE(J) .NE. 4 .AND. C) THEN
                            R = SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,J), SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,J) ))
                            IF(R<RMIN) THEN
                                RMIN = R
                                JMIN = J
                            END IF
                        END IF
                    END DO
                    IF(JMIN.NE.0) THEN
                        SURFACE_FLUID%SURFACE_POINTS(:,JMIN) = SURFACE_CASE%SURFACE_POINTS(:,I)
                    END IF
                END IF
            END IF
        END DO
    
    END SUBROUTINE MAINTAIN_CASE_CORNER
    
    SUBROUTINE GENERATE_FACES_CASE(POINT_NUM, POINT, FACE_NUM, FACE, NEW_FACE)
        IMPLICIT NONE
        INTEGER :: POINT_NUM
        REAL(8) :: POINT(3,POINT_NUM)
        INTEGER :: FACE_NUM
        INTEGER :: FACE(4,FACE_NUM)
        INTEGER :: NEW_FACE(3,2*FACE_NUM)
        
        INTEGER :: I
        REAL(8) :: V1(3),V2(3),V3(3),V4(3), R1, R2
        
        DO I=1,FACE_NUM
            V1 = POINT(:,FACE(1,I))
            V2 = POINT(:,FACE(2,I))
            V3 = POINT(:,FACE(3,I))
            V4 = POINT(:,FACE(4,I))
            
            R1 = SQRT(DOT_PRODUCT(V3-V1,V3-V1))
            R2 = SQRT(DOT_PRODUCT(V4-V2,V4-V2))
            
            IF(R1<R2) THEN
                NEW_FACE(1,2*I-1) = FACE(4,I)
                NEW_FACE(2,2*I-1) = FACE(3,I)
                NEW_FACE(3,2*I-1) = FACE(2,I)
                
                NEW_FACE(1,2*I) = FACE(4,I)
                NEW_FACE(2,2*I) = FACE(2,I)
                NEW_FACE(3,2*I) = FACE(1,I)
                
                !NEW_FACE(1,2*I-1) = FACE(1,I)
                !NEW_FACE(2,2*I-1) = FACE(2,I)
                !NEW_FACE(3,2*I-1) = FACE(3,I)
                
                !NEW_FACE(1,2*I) = FACE(1,I)
                !NEW_FACE(2,2*I) = FACE(3,I)
                !NEW_FACE(3,2*I) = FACE(4,I)
            ELSE
                NEW_FACE(1,2*I-1) = FACE(3,I)
                NEW_FACE(2,2*I-1) = FACE(2,I)
                NEW_FACE(3,2*I-1) = FACE(1,I)
                
                NEW_FACE(1,2*I) = FACE(3,I)
                NEW_FACE(2,2*I) = FACE(1,I)
                NEW_FACE(3,2*I) = FACE(4,I)
                
                !NEW_FACE(1,2*I-1) = FACE(2,I)
                !NEW_FACE(2,2*I-1) = FACE(3,I)
                !NEW_FACE(3,2*I-1) = FACE(4,I)
                
                !NEW_FACE(1,2*I) = FACE(2,I)
                !NEW_FACE(2,2*I) = FACE(4,I)
                !NEW_FACE(3,2*I) = FACE(1,I)
            END IF
        END DO
    END SUBROUTINE GENERATE_FACES_CASE
    
    SUBROUTINE GENERATE_LOCATION_CASE(LOC_NUM, OLD_LOC, NEW_LOC)
        IMPLICIT NONE
        INTEGER :: LOC_NUM
        INTEGER :: OLD_LOC(LOC_NUM)
        INTEGER :: NEW_LOC(2*LOC_NUM)
        
        INTEGER :: I
        
        DO I=1,LOC_NUM
            NEW_LOC(2*I-1) = OLD_LOC(I)
            NEW_LOC(2*I) = OLD_LOC(I)
        END DO
    END SUBROUTINE GENERATE_LOCATION_CASE
    
    SUBROUTINE RESET_SURFACE(TYP, FLAG, POINT_NUM, FACE_NUM, SURFACE_POINTS, SURFACE_FACES, &
    SURFACE_INITIAL_FACE_AREA, SURFACE_INITIAL_EDGE_LENGTH, FACE_B_RATE, POINT_VELOCITY, POINT_DISPLACEMENT, &
    POINT_FACE_CONNECTION, POINT_FACE_CONNECTION_NUM, POINT_TYPE, FACE_LOCATION, FACE_ONINTERFACE, POINT_RELATEDPT, POINT_RELATEDFACE, FACE_PRESSURE, POINT_FORCE, POINT_DISTANCE, FACE_IMPACT_ZONE, FACE_ABLATION_FLAG, FACE_DIVIDED_REGION_ARRAY, FACE_DIVIDED_BOUNDARY_ARRAY)
	IMPLICIT NONE
        INTEGER :: TYP
        LOGICAL :: FLAG
        INTEGER :: POINT_NUM, FACE_NUM
        
        REAL(8), OPTIONAL :: SURFACE_POINTS(3,POINT_NUM)
        INTEGER, OPTIONAL :: SURFACE_FACES(:,:)
    
        REAL(8), OPTIONAL :: SURFACE_INITIAL_FACE_AREA(FACE_NUM)
        REAL(8), OPTIONAL :: SURFACE_INITIAL_EDGE_LENGTH(3,FACE_NUM)
        
        REAL(8), OPTIONAL :: FACE_B_RATE(FACE_NUM)
        REAL(8), OPTIONAL :: POINT_VELOCITY(3,POINT_NUM)
        REAL(8), OPTIONAL :: POINT_DISPLACEMENT(3,POINT_NUM)
        INTEGER, OPTIONAL :: POINT_FACE_CONNECTION(30,POINT_NUM)
        INTEGER, OPTIONAL :: POINT_FACE_CONNECTION_NUM(POINT_NUM)
        INTEGER, OPTIONAL :: POINT_TYPE(POINT_NUM)  
       
	INTEGER, OPTIONAL :: FACE_LOCATION(FACE_NUM)
        INTEGER, OPTIONAL :: FACE_ONINTERFACE(FACE_NUM)
        
        INTEGER, OPTIONAL :: POINT_RELATEDPT(3,POINT_NUM)
        INTEGER, OPTIONAL :: POINT_RELATEDFACE(3,POINT_NUM)
        
        REAL(8), OPTIONAL :: FACE_PRESSURE(FACE_NUM)
        REAL(8), OPTIONAL :: POINT_FORCE(3,POINT_NUM)
        REAL(8), OPTIONAL :: POINT_DISTANCE(3,POINT_NUM)
        
        INTEGER, OPTIONAL :: FACE_IMPACT_ZONE(3,FACE_NUM)
        INTEGER, OPTIONAL :: FACE_ABLATION_FLAG(FACE_NUM)
        
        INTEGER, OPTIONAL :: FACE_DIVIDED_REGION_ARRAY(FACE_NUM)
        INTEGER, OPTIONAL :: FACE_DIVIDED_BOUNDARY_ARRAY(3,FACE_NUM)
        
        INTEGER :: I, I1, I2, I3
        REAL(8) :: R, V1(3), V2(3), V3(3), N(3), L, R1, R2, R3
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_POINTS)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_POINTS)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_FACES)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_FACES)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_B_RATE)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_B_RATE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_VELOCITY)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_VELOCITY)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_DISPLACEMENT)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_DISPLACEMENT)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_FACE_CONNECTION)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_TYPE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_TYPE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%INITIAL_POINT_TYPE)) THEN
            DEALLOCATE(SURFACE_CURRENT%INITIAL_POINT_TYPE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_LOCATION)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_LOCATION)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_ONINTERFACE)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_ONINTERFACE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_RELATEDPT)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_RELATEDPT)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_RELATEDFACE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_RELATEDFACE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_PRESSURE)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_PRESSURE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_FORCE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_FORCE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_DISTANCE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_DISTANCE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_IMPACT_ZONE)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_IMPACT_ZONE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_ABLATION_FLAG)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_ABLATION_FLAG)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)) THEN
            DEALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)
        END IF

        IF(FLAG) THEN
            
            SURFACE_CURRENT%SURFACE_POINTS_NUM = POINT_NUM
            SURFACE_CURRENT%SURFACE_FACES_NUM = FACE_NUM
            
            ALLOCATE(SURFACE_CURRENT%SURFACE_POINTS(3,POINT_NUM))
            !IF(TYP==0) THEN
                ALLOCATE(SURFACE_CURRENT%SURFACE_FACES(3,FACE_NUM))
            !ELSE
            !    ALLOCATE(SURFACE_CURRENT%SURFACE_FACES(4,FACE_NUM))
            !END IF
            ALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(3,FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_B_RATE(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_VELOCITY(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_DISPLACEMENT(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION(30,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_TYPE(POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%INITIAL_POINT_TYPE(POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_LOCATION(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_ONINTERFACE(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_RELATEDPT(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_RELATEDFACE(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_PRESSURE(FACE_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_FORCE(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_DISTANCE(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%FACE_IMPACT_ZONE(3,FACE_NUM))
	    ALLOCATE(SURFACE_CURRENT%FACE_ABLATION_FLAG(FACE_NUM))
	    ALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(FACE_NUM))
	    ALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(3,FACE_NUM))
            
            IF(PRESENT(SURFACE_POINTS)) THEN
                SURFACE_CURRENT%SURFACE_POINTS(:,:) = SURFACE_POINTS(:,:)
            END IF
            
            IF(PRESENT(SURFACE_FACES)) THEN
                SURFACE_CURRENT%SURFACE_FACES(:,:) = SURFACE_FACES(:,:)
            END IF
            
            IF(PRESENT(SURFACE_INITIAL_FACE_AREA)) THEN
                SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(:) = SURFACE_INITIAL_FACE_AREA(:)
                SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(:,:) = SURFACE_INITIAL_EDGE_LENGTH(:,:)
            ELSE
                SURFACE_CURRENT%MESH_SIZE = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
                SURFACE_CURRENT%MESH_SIZE_MAX = 0.
                
                !$OMP PARALLEL DO PRIVATE(I,R),REDUCTION(MIN:MESH_SIZE),REDUCTION(MAX:MESH_SIZE_MAX)
                DO I = 1, FACE_NUM
                    
                    I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
                    I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
                    I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
                    
                    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                    V3 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I3)
                    
                    CALL VEC_CURL1(V1,V2, N)
                    
                    R = SQRT(DOT_PRODUCT(N,N))/2
                
                    SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(I) = R
                    SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(1,I) = SQRT(DOT_PRODUCT(V1,V1))
                    SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(2,I) = SQRT(DOT_PRODUCT(V3,V3))
                    SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(3,I) = SQRT(DOT_PRODUCT(V2,V2))
                    
                    R1 = SQRT(DOT_PRODUCT(V1,V1))
                    R2 = SQRT(DOT_PRODUCT(V2,V2))
                    R3 = SQRT(DOT_PRODUCT(V3,V3))
                    L = (R1 + R2 + R3) / 3.
                    
                    IF(SURFACE_CURRENT%MESH_SIZE > L) THEN
                        SURFACE_CURRENT%MESH_SIZE = L
                    END IF
                    IF(SURFACE_CURRENT%MESH_SIZE_MAX < L) THEN
                        SURFACE_CURRENT%MESH_SIZE_MAX = L
                    END IF
                END DO
                !$OMP END PARALLEL DO
            END IF
            
            IF(PRESENT(FACE_B_RATE)) THEN
                SURFACE_CURRENT%FACE_B_RATE(:) = FACE_B_RATE(:)
            ELSE
                SURFACE_CURRENT%FACE_B_RATE(:) = 0.
            END IF
            
            IF(PRESENT(POINT_VELOCITY)) THEN
                SURFACE_CURRENT%POINT_VELOCITY(:,:) = POINT_VELOCITY(:,:)
            ELSE
                SURFACE_CURRENT%POINT_VELOCITY(:,:) = 0.
            END IF
            
            IF(PRESENT(POINT_DISPLACEMENT)) THEN
                SURFACE_CURRENT%POINT_DISPLACEMENT(:,:) = POINT_DISPLACEMENT(:,:)
            ELSE
                SURFACE_CURRENT%POINT_DISPLACEMENT(:,:) = 0.
            END IF
            
            IF(PRESENT(POINT_FACE_CONNECTION)) THEN
                SURFACE_CURRENT%POINT_FACE_CONNECTION(:,:) = POINT_FACE_CONNECTION(:,:)
                SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(:) = POINT_FACE_CONNECTION_NUM(:)
            ELSE
                CALL POINT_FACE_CONNECTING(TYP)
            END IF
            
            IF(PRESENT(FACE_LOCATION)) THEN
                SURFACE_CURRENT%FACE_LOCATION(:) = FACE_LOCATION(:)
	        CALL FIND_PATCH_NUM(TYP)
	        ALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_CURRENT%SURFACE_PATCHES_NUM))
            ELSE
		CALL FIND_PATCH_NUM(TYP)
	        ALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_CURRENT%SURFACE_PATCHES_NUM)) 
                SURFACE_CURRENT%FACE_LOCATION(:) = -1
            END IF
            IF(PRESENT(POINT_DISTANCE)) THEN
                SURFACE_CURRENT%POINT_DISTANCE(:,:) = POINT_DISTANCE(:,:)
            ELSE
                SURFACE_CURRENT%POINT_DISTANCE(:,:) = 0.
            END IF
            
            IF(PRESENT(FACE_ONINTERFACE)) THEN
                SURFACE_CURRENT%FACE_ONINTERFACE(:) = FACE_ONINTERFACE(:)
            ELSE
               !CALL FIND_INTERFACE(TYP,2)
                SURFACE_CURRENT%FACE_ONINTERFACE(:) = -1
            END IF
            
            IF(PRESENT(POINT_RELATEDPT)) THEN
                SURFACE_CURRENT%POINT_RELATEDPT(:,:) = POINT_RELATEDPT(:,:)
            ELSE
                SURFACE_CURRENT%POINT_RELATEDPT(:,:) = 0
            END IF
            
            IF(PRESENT(POINT_RELATEDFACE)) THEN
                SURFACE_CURRENT%POINT_RELATEDFACE(:,:) = POINT_RELATEDFACE(:,:)
            ELSE
                SURFACE_CURRENT%POINT_RELATEDFACE(:,:) = 0
            END IF
            IF(PRESENT(FACE_PRESSURE)) THEN
                SURFACE_CURRENT%FACE_PRESSURE(:) = FACE_PRESSURE(:)
            ELSE
                SURFACE_CURRENT%FACE_PRESSURE(:) = 0.
            END IF
            IF(PRESENT(POINT_FORCE)) THEN
                SURFACE_CURRENT%POINT_FORCE(:,:) = POINT_FORCE(:,:)
            ELSE
                SURFACE_CURRENT%POINT_FORCE(:,:) = 0.
            END IF           
            IF(PRESENT(FACE_IMPACT_ZONE)) THEN
                SURFACE_CURRENT%FACE_IMPACT_ZONE(:,:) = FACE_IMPACT_ZONE(:,:)
            ELSE
                SURFACE_CURRENT%FACE_IMPACT_ZONE(:,:) = 0
            END IF
            
            IF(PRESENT(POINT_TYPE)) THEN
                SURFACE_CURRENT%POINT_TYPE(:) = POINT_TYPE(:)
                SURFACE_CURRENT%INITIAL_POINT_TYPE(:) = POINT_TYPE(:)
            ELSE
                CALL FIND_POINT_TYPE(TYP)
                SURFACE_CURRENT%INITIAL_POINT_TYPE(:) = SURFACE_CURRENT%POINT_TYPE(:)
            END IF
	    IF(TYP == 0 .OR. TYP == 1) THEN
                SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(:) = 0
	    END IF

            IF(PRESENT(FACE_ABLATION_FLAG)) THEN
                SURFACE_CURRENT%FACE_ABLATION_FLAG(:) = FACE_ABLATION_FLAG(:)
            ELSE
                SURFACE_CURRENT%FACE_ABLATION_FLAG(:) = 0
            END IF

            IF(PRESENT(FACE_DIVIDED_REGION_ARRAY)) THEN
                SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(:) = FACE_DIVIDED_REGION_ARRAY(:)
            ELSE
                SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(:) = 0
            END IF

            IF(PRESENT(FACE_DIVIDED_BOUNDARY_ARRAY)) THEN
                SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,:) = FACE_DIVIDED_BOUNDARY_ARRAY(:,:)
            ELSE
                SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,:) = 0
            END IF
            
        END IF
    END SUBROUTINE RESET_SURFACE
END MODULE PROPA_RECONST_REINITIAL_3D
